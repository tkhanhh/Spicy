--== Load Mac Library thay cho Ash-Libs ==--
-- Đã thay thế MacLib gốc bằng một thư viện UI tuỳ chỉnh mô phỏng phong cách Chilli Finder.
-- Thư viện này dựng một cửa sổ chính với thanh tab bên trái và khu vực điều khiển bên phải.
-- Các hàm Window, TabGroup, Tab, Section và các control (Toggle, Dropdown, Input, Button, Paragraph) được xây dựng lại
-- để sử dụng giao diện tối, hiện đại, tối giản dựa trên bảng màu của Chilli Finder.
local MacLib = {}
do
    --==========================
    -- Palette & Helpers
    --==========================
    local COLOR_BASE_BG      = Color3.fromRGB(16, 24, 39)
    local COLOR_CARD_GRAD_1  = Color3.fromRGB(12, 18, 32)
    local COLOR_CARD_GRAD_2  = Color3.fromRGB(21, 30, 47)
    local COLOR_CARD_GRAD_3  = Color3.fromRGB(10, 82, 120)
    local COLOR_SURFACE      = Color3.fromRGB(30, 41, 59)
    local COLOR_SURFACE_DARK = Color3.fromRGB(25, 32, 48)
    local COLOR_TEAL_ON      = Color3.fromRGB(52, 180, 230)
    local COLOR_STROKE_GLOW  = Color3.fromRGB(56, 189, 248)
    local COLOR_STROKE_MAIN  = Color3.fromRGB(56, 189, 248)
    local COLOR_TEXT         = Color3.fromRGB(241, 245, 249)
    local COLOR_TEXT_MUTED   = Color3.fromRGB(148, 163, 184)

    local function makeCard(parent, sizeUDim2)
        -- Tạo thẻ có nền gradient và stroke mờ
        local frame = Instance.new('Frame')
        frame.BackgroundColor3 = COLOR_BASE_BG
        frame.BorderSizePixel  = 0
        frame.Size             = sizeUDim2
        frame.Parent           = parent
        Instance.new('UICorner', frame).CornerRadius = UDim.new(0, 20)
        -- gradient nền
        local g = Instance.new('UIGradient', frame)
        g.Rotation = 35
        g.Color    = ColorSequence.new({
            ColorSequenceKeypoint.new(0.00, COLOR_CARD_GRAD_1),
            ColorSequenceKeypoint.new(0.55, COLOR_CARD_GRAD_2),
            ColorSequenceKeypoint.new(1.00, COLOR_CARD_GRAD_3),
        })
        -- vệt sáng mờ bên ngoài
        local s1 = Instance.new('UIStroke', frame)
        s1.Thickness     = 8
        s1.Transparency  = 0.9
        s1.LineJoinMode  = Enum.LineJoinMode.Round
        s1.Color         = COLOR_STROKE_GLOW
        -- viền chính
        local s2 = Instance.new('UIStroke', frame)
        s2.Thickness     = 2
        s2.Transparency  = 0.15
        s2.LineJoinMode  = Enum.LineJoinMode.Round
        s2.Color         = COLOR_STROKE_MAIN
        return frame
    end

    local function makeTopBar(parent, title)
        -- Tạo thanh tiêu đề ở trên
        local bar = Instance.new('Frame')
        bar.Name                   = 'TopBar'
        bar.Parent                 = parent
        bar.BackgroundColor3       = Color3.fromRGB(18, 26, 42)
        bar.BackgroundTransparency = 0.15
        bar.BorderSizePixel        = 0
        bar.Size                   = UDim2.new(1, 0, 0, 46)
        Instance.new('UICorner', bar).CornerRadius = UDim.new(0, 20)
        local lbl = Instance.new('TextLabel')
        lbl.Name            = 'Title'
        lbl.BackgroundTransparency = 1
        lbl.Position        = UDim2.new(0, 16, 0, 0)
        lbl.Size            = UDim2.new(1, -160, 1, 0)
        lbl.Font            = Enum.Font.GothamBold
        lbl.Text            = title or ''
        lbl.TextXAlignment  = Enum.TextXAlignment.Left
        lbl.TextSize        = 16
        lbl.TextColor3      = COLOR_TEXT
        lbl.AutoLocalize    = false
        lbl.Parent          = bar
        -- gradient màu tiêu đề
        local grad = Instance.new('UIGradient', lbl)
        grad.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0.00, Color3.fromRGB(34, 211, 238)),
            ColorSequenceKeypoint.new(0.50, Color3.fromRGB(255, 255, 255)),
            ColorSequenceKeypoint.new(1.00, Color3.fromRGB(99, 102, 241)),
        })
        return bar, lbl
    end

    -- Nhóm kéo cho cửa sổ (DragGroup): hỗ trợ kéo toàn bộ cửa sổ
    local DragGroup = { frames = {}, dragging = false, dragStart = nil, groupStart = {} }
    function DragGroup:register(frame, topbar)
        table.insert(self.frames, { frame = frame, top = topbar })
        topbar.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                self.dragging  = true
                self.dragStart = input.Position
                self.groupStart= {}
                for _, it in ipairs(self.frames) do
                    self.groupStart[it] = it.frame.Position
                end
                input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        self.dragging = false
                    end
                end)
            end
        end)
        topbar.InputChanged:Connect(function(input)
            if self.dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
                local delta = input.Position - self.dragStart
                for _, it in ipairs(self.frames) do
                    local startPos = self.groupStart[it]
                    it.frame.Position = UDim2.new(
                        startPos.X.Scale,
                        startPos.X.Offset + delta.X,
                        startPos.Y.Scale,
                        startPos.Y.Offset + delta.Y
                    )
                end
            end
        end)
    end

    --==========================
    -- MacLib.Window Implementation
    --==========================
    function MacLib:Window(opts)
        opts = opts or {}
        local window = {}
        local UIS = game:GetService("UserInputService")
        -- Create ScreenGui for the window
        local sg = Instance.new('ScreenGui')
        sg.Name            = 'ChilliMacUI'
        sg.IgnoreGuiInset  = true
        sg.ResetOnSpawn    = false
        sg.ZIndexBehavior  = Enum.ZIndexBehavior.Global
        sg.Parent          = game:GetService('CoreGui')
        -- main card
        local size = opts.Size or UDim2.fromOffset(860, 560)
        local card = makeCard(sg, size)
        -- centering by default
        card.Position      = UDim2.new(0.5, -size.X.Offset/2, 0.5, -size.Y.Offset/2)
        -- top bar
        local topBar, titleLbl = makeTopBar(card, opts.Title or '')
        -- container for sidebar and content
        local container = Instance.new('Frame')
        container.Name = 'Container'
        container.BackgroundTransparency = 1
        container.Size = UDim2.new(1, -20, 1, -60)
        container.Position = UDim2.new(0, 10, 0, 50)
        container.Parent = card
        -- left panel for tabs
        local tabsFrame = Instance.new('Frame')
        tabsFrame.Name = 'TabsFrame'
        tabsFrame.BackgroundColor3 = COLOR_SURFACE_DARK
        tabsFrame.BorderSizePixel  = 0
        tabsFrame.Size = UDim2.new(0, 140, 1, 0)
        tabsFrame.Parent = container
        Instance.new('UICorner', tabsFrame).CornerRadius = UDim.new(0, 14)
        local tabsLayout = Instance.new('UIListLayout', tabsFrame)
        tabsLayout.FillDirection = Enum.FillDirection.Vertical
        tabsLayout.SortOrder     = Enum.SortOrder.LayoutOrder
        tabsLayout.Padding       = UDim.new(0, 4)
        -- right panel for content
        local contentFrame = Instance.new('Frame')
        contentFrame.Name = 'ContentFrame'
        contentFrame.BackgroundColor3 = COLOR_SURFACE
        contentFrame.BorderSizePixel  = 0
        contentFrame.Size = UDim2.new(1, -160, 1, 0)
        contentFrame.Position = UDim2.new(0, 150, 0, 0)
        contentFrame.Parent = container
        Instance.new('UICorner', contentFrame).CornerRadius = UDim.new(0, 14)
        -- hold current tab
        window._tabs = {}
        window._selectedTab = nil
        window._sg = sg
        window._card = card
        window._tabsFrame = tabsFrame
        window._contentFrame = contentFrame
        window._open = true
        -- Toggling methods
        function window:Toggle()
            self._open = not self._open
            sg.Enabled = self._open
        end
        function window:GetOpen()
            return self._open
        end
        function window:SetOpen(b)
            self._open = b
            sg.Enabled = b
        end
        function window:ToggleUI()
            self:Toggle()
        end
        function window:ToggleMain()
            self:Toggle()
        end
        -- Drag support
        DragGroup:register(card, topBar)
        -- Keybind support
        if opts.Keybind and typeof(opts.Keybind) == 'EnumItem' then
            UIS.InputBegan:Connect(function(input, gpe)
                if not gpe and input.KeyCode == opts.Keybind then
                    window:Toggle()
                end
            end)
        end
        -- TabGroup object
        local TabGroup = {}
        function TabGroup:Tab(info)
            info = info or {}
            local tab = {}
            tab._sections = {}
            tab._title = info.Title or 'Tab'
            -- create tab button in sidebar
            local btn = Instance.new('TextButton')
            btn.Name               = 'TabButton_' .. tab._title
            btn.Text               = tab._title
            btn.Font               = Enum.Font.GothamBold
            btn.TextSize           = 14
            btn.TextColor3         = COLOR_TEXT
            btn.AutoButtonColor    = false
            btn.BackgroundColor3   = COLOR_SURFACE
            btn.Size               = UDim2.new(1, -8, 0, 36)
            btn.Position           = UDim2.new(0, 4, 0, 0)
            Instance.new('UICorner', btn).CornerRadius = UDim.new(0, 10)
            -- highlight line
            local highlight = Instance.new('Frame')
            highlight.Name             = 'Highlight'
            highlight.Parent           = btn
            highlight.BackgroundColor3 = COLOR_TEAL_ON
            highlight.BorderSizePixel  = 0
            highlight.Size             = UDim2.new(0, 4, 1, 0)
            highlight.Position         = UDim2.new(0, 0, 0, 0)
            highlight.Visible          = false
            highlight.ZIndex           = btn.ZIndex + 1
            btn.Parent = tabsFrame
            -- create content container for this tab
            local tabContent = Instance.new('ScrollingFrame')
            tabContent.Name               = 'TabContent_' .. tab._title
            tabContent.BackgroundTransparency = 1
            tabContent.BorderSizePixel    = 0
            tabContent.Position           = UDim2.new(0, 10, 0, 10)
            tabContent.Size               = UDim2.new(1, -20, 1, -20)
            tabContent.CanvasSize         = UDim2.new(0, 0, 0, 0)
            tabContent.ScrollBarThickness = 4
            tabContent.ScrollingDirection = Enum.ScrollingDirection.Y
            tabContent.AutomaticCanvasSize = Enum.AutomaticSize.Y
            tabContent.Visible            = false
            tabContent.Parent             = contentFrame
            local listLayout = Instance.new('UIListLayout', tabContent)
            listLayout.Padding   = UDim.new(0, 6)
            listLayout.SortOrder = Enum.SortOrder.LayoutOrder
            -- show/hide logic
            local function selectTab()
                -- hide previous
                if window._selectedTab and window._selectedTab._content then
                    window._selectedTab._content.Visible = false
                    window._selectedTab._btn.BackgroundColor3 = COLOR_SURFACE
                    window._selectedTab._btn.Highlight.Visible = false
                end
                -- set this
                window._selectedTab = tab
                tabContent.Visible  = true
                btn.BackgroundColor3= COLOR_SURFACE_DARK
                highlight.Visible   = true
            end
            btn.MouseButton1Click:Connect(function()
                selectTab()
            end)
            -- if first tab, select by default
            table.insert(window._tabs, tab)
            if #window._tabs == 1 then
                selectTab()
            end
            -- store references on tab object
            tab._btn     = btn
            tab._content = tabContent
            -- Section creation
            function tab:Section(secInfo)
                secInfo = secInfo or {}
                local section = {}
                section._controls = {}
                -- section frame
                local sFrame = Instance.new('Frame')
                sFrame.Name       = 'Section_' .. (secInfo.Title or '')
                sFrame.BackgroundColor3 = COLOR_SURFACE_DARK
                sFrame.BorderSizePixel  = 0
                sFrame.Size       = UDim2.new(1, 0, 0, 0)
                sFrame.AutomaticSize = Enum.AutomaticSize.Y
                sFrame.Parent     = tabContent
                Instance.new('UICorner', sFrame).CornerRadius = UDim.new(0, 12)
                local sLayout = Instance.new('UIListLayout', sFrame)
                sLayout.FillDirection = Enum.FillDirection.Vertical
                sLayout.SortOrder     = Enum.SortOrder.LayoutOrder
                sLayout.Padding       = UDim.new(0, 4)
                -- title label
                if secInfo.Title and secInfo.Title ~= '' then
                    local titleLbl = Instance.new('TextLabel')
                    titleLbl.Name               = 'SectionTitle'
                    titleLbl.Text               = tostring(secInfo.Title)
                    titleLbl.Font               = Enum.Font.GothamSemibold
                    titleLbl.TextSize           = 16
                    titleLbl.TextColor3         = COLOR_TEAL_ON
                    titleLbl.BackgroundTransparency = 1
                    titleLbl.Position           = UDim2.new(0, 8, 0, 6)
                    titleLbl.Size               = UDim2.new(1, -16, 0, 20)
                    titleLbl.TextXAlignment     = Enum.TextXAlignment.Left
                    titleLbl.Parent             = sFrame
                end
                -- controls container
                local cFrame = Instance.new('Frame')
                cFrame.Name           = 'Controls'
                cFrame.BackgroundTransparency = 1
                cFrame.Size           = UDim2.new(1, -16, 0, 0)
                cFrame.Position       = UDim2.new(0, 8, 0, 0)
                cFrame.AutomaticSize  = Enum.AutomaticSize.Y
                cFrame.Parent         = sFrame
                local cLayout = Instance.new('UIListLayout', cFrame)
                cLayout.FillDirection = Enum.FillDirection.Vertical
                cLayout.SortOrder     = Enum.SortOrder.LayoutOrder
                cLayout.Padding       = UDim.new(0, 6)
                -- Control creators
                function section:Paragraph(info)
                    info = info or {}
                    local row = Instance.new('Frame')
                    row.BackgroundColor3 = COLOR_SURFACE
                    row.BorderSizePixel  = 0
                    row.Size             = UDim2.new(1, 0, 0, 0)
                    row.AutomaticSize    = Enum.AutomaticSize.Y
                    Instance.new('UICorner', row).CornerRadius = UDim.new(0, 10)
                    row.Parent           = cFrame
                    local txt = Instance.new('TextLabel')
                    txt.BackgroundTransparency = 1
                    txt.Font               = Enum.Font.Gotham
                    txt.TextWrapped        = true
                    txt.TextColor3         = COLOR_TEXT_MUTED
                    txt.TextSize           = 14
                    txt.TextXAlignment     = Enum.TextXAlignment.Left
                    txt.TextYAlignment     = Enum.TextYAlignment.Top
                    txt.Position           = UDim2.new(0, 8, 0, 6)
                    txt.Size               = UDim2.new(1, -16, 0, 0)
                    txt.AutomaticSize      = Enum.AutomaticSize.Y
                    local fullText = ''
                    if info.Title and info.Title ~= '' then
                        fullText = info.Title
                    end
                    if info.Desc and info.Desc ~= '' then
                        if fullText ~= '' then fullText = fullText .. '\n' .. info.Desc else fullText = info.Desc end
                    end
                    txt.Text = fullText
                    txt.Parent = row
                    return {}
                end
                function section:Button(info)
                    info = info or {}
                    local row = Instance.new('TextButton')
                    row.BackgroundColor3 = COLOR_SURFACE
                    row.BorderSizePixel  = 0
                    row.Size             = UDim2.new(1, 0, 0, 36)
                    row.AutoButtonColor  = true
                    row.Text             = ''
                    Instance.new('UICorner', row).CornerRadius = UDim.new(0, 10)
                    row.Parent           = cFrame
                    local lbl = Instance.new('TextLabel')
                    lbl.BackgroundTransparency = 1
                    lbl.Text               = tostring(info.Title or 'Button')
                    lbl.Font               = Enum.Font.GothamSemibold
                    lbl.TextSize           = 14
                    lbl.TextColor3         = COLOR_TEXT
                    lbl.Size               = UDim2.new(1, -16, 1, 0)
                    lbl.Position           = UDim2.new(0, 8, 0, 0)
                    lbl.TextXAlignment     = Enum.TextXAlignment.Left
                    lbl.Parent = row
                    row.MouseButton1Click:Connect(function()
                        if type(info.Callback) == 'function' then
                            task.spawn(function()
                                info.Callback()
                            end)
                        end
                    end)
                    return {}
                end
                function section:Toggle(info)
                    info = info or {}
                    local row = Instance.new('Frame')
                    row.BackgroundColor3 = COLOR_SURFACE
                    row.BorderSizePixel  = 0
                    row.Size             = UDim2.new(1, 0, 0, 36)
                    Instance.new('UICorner', row).CornerRadius = UDim.new(0, 10)
                    row.Parent           = cFrame
                    local lbl = Instance.new('TextLabel')
                    lbl.BackgroundTransparency = 1
                    lbl.Text               = tostring(info.Title or 'Toggle')
                    lbl.Font               = Enum.Font.GothamSemibold
                    lbl.TextSize           = 14
                    lbl.TextColor3         = COLOR_TEXT
                    lbl.Size               = UDim2.new(1, -60, 1, 0)
                    lbl.Position           = UDim2.new(0, 8, 0, 0)
                    lbl.TextXAlignment     = Enum.TextXAlignment.Left
                    lbl.Parent = row
                    -- toggle button
                    local tgBtn = Instance.new('Frame')
                    tgBtn.Name               = 'Switch'
                    tgBtn.Size               = UDim2.fromOffset(40, 20)
                    tgBtn.Position           = UDim2.new(1, -48, 0.5, -10)
                    tgBtn.BackgroundColor3   = COLOR_SURFACE_DARK
                    tgBtn.BorderSizePixel    = 0
                    Instance.new('UICorner', tgBtn).CornerRadius = UDim.new(0, 10)
                    local knob = Instance.new('Frame')
                    knob.Name                 = 'Knob'
                    knob.Size                 = UDim2.fromOffset(18, 18)
                    knob.Position             = UDim2.new(0, 1, 0, 1)
                    knob.BackgroundColor3     = COLOR_TEXT_MUTED
                    knob.BorderSizePixel      = 0
                    Instance.new('UICorner', knob).CornerRadius = UDim.new(1, 0)
                    knob.Parent = tgBtn
                    tgBtn.Parent = row
                    local state = (info.Default == true)
                    local function updateVisual()
                        if state then
                            tgBtn.BackgroundColor3 = COLOR_TEAL_ON
                            knob.Position = UDim2.new(1, -19, 0, 1)
                            knob.BackgroundColor3 = COLOR_SURFACE
                        else
                            tgBtn.BackgroundColor3 = COLOR_SURFACE_DARK
                            knob.Position = UDim2.new(0, 1, 0, 1)
                            knob.BackgroundColor3 = COLOR_TEXT_MUTED
                        end
                    end
                    updateVisual()
                    row.InputBegan:Connect(function(input)
                        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                            state = not state
                            updateVisual()
                            if type(info.Callback) == 'function' then
                                task.spawn(function()
                                    info.Callback(state)
                                end)
                            end
                        end
                    end)
                    return {}
                end
                function section:Dropdown(info)
                    info = info or {}
                    local row = Instance.new('Frame')
                    row.BackgroundColor3 = COLOR_SURFACE
                    row.BorderSizePixel  = 0
                    row.Size             = UDim2.new(1, 0, 0, 36)
                    Instance.new('UICorner', row).CornerRadius = UDim.new(0, 10)
                    row.Parent           = cFrame
                    local lbl = Instance.new('TextLabel')
                    lbl.BackgroundTransparency = 1
                    lbl.Text               = tostring(info.Title or 'Select')
                    lbl.Font               = Enum.Font.GothamSemibold
                    lbl.TextSize           = 14
                    lbl.TextColor3         = COLOR_TEXT
                    lbl.Size               = UDim2.new(1, -60, 1, 0)
                    lbl.Position           = UDim2.new(0, 8, 0, 0)
                    lbl.TextXAlignment     = Enum.TextXAlignment.Left
                    lbl.Parent             = row
                    -- selected display
                    local selLbl = Instance.new('TextLabel')
                    selLbl.BackgroundTransparency = 1
                    selLbl.Text               = ''
                    selLbl.Font               = Enum.Font.Gotham
                    selLbl.TextSize           = 13
                    selLbl.TextColor3         = COLOR_TEXT_MUTED
                    selLbl.Size               = UDim2.new(1, -60, 1, 0)
                    selLbl.Position           = UDim2.new(0, 8, 0, 0)
                    selLbl.TextXAlignment     = Enum.TextXAlignment.Right
                    selLbl.Parent             = row
                    -- dropdown container
                    local listFrame = Instance.new('Frame')
                    listFrame.Name            = 'DropList'
                    listFrame.Parent          = cFrame
                    listFrame.BackgroundColor3= COLOR_SURFACE_DARK
                    listFrame.BorderSizePixel = 0
                    listFrame.Size            = UDim2.new(1, -16, 0, 0)
                    listFrame.Position        = UDim2.new(0, 8, 0, 0)
                    listFrame.Visible         = false
                    Instance.new('UICorner', listFrame).CornerRadius = UDim.new(0, 8)
                    local listLayout = Instance.new('UIListLayout', listFrame)
                    listLayout.FillDirection = Enum.FillDirection.Vertical
                    listLayout.SortOrder     = Enum.SortOrder.LayoutOrder
                    listLayout.Padding       = UDim.new(0, 4)
                    -- scroll for list if too long
                    local scroller = Instance.new('ScrollingFrame')
                    scroller.Parent           = listFrame
                    scroller.BackgroundTransparency = 1
                    scroller.BorderSizePixel  = 0
                    scroller.Size             = UDim2.new(1, 0, 0, 0)
                    scroller.Position         = UDim2.new(0, 0, 0, 0)
                    scroller.AutomaticSize    = Enum.AutomaticSize.Y
                    scroller.ScrollBarThickness = 4
                    scroller.ScrollingDirection = Enum.ScrollingDirection.Y
                    scroller.CanvasSize       = UDim2.new(0, 0, 0, 0)
                    local scLayout = Instance.new('UIListLayout', scroller)
                    scLayout.FillDirection   = Enum.FillDirection.Vertical
                    scLayout.SortOrder       = Enum.SortOrder.LayoutOrder
                    scLayout.Padding         = UDim.new(0, 2)
                    -- selection state
                    local selected = {}
                    local function updateSelectedLabel()
                        if info.Multi then
                            local names = {}
                            for _, v in ipairs(selected) do
                                table.insert(names, tostring(v))
                            end
                            selLbl.Text = table.concat(names, ', ')
                        else
                            selLbl.Text = tostring(selected[1] or '')
                        end
                    end
                    -- populate options
                    local opts = info.Options or {}
                    -- convert default to table
                    local defaults = {}
                    if info.Default then
                        if type(info.Default) == 'table' then
                            defaults = info.Default
                        else
                            defaults = { info.Default }
                        end
                    end
                    for _, opt in ipairs(opts) do
                        local oBtn = Instance.new('TextButton')
                        oBtn.Name              = 'Option_' .. tostring(opt)
                        oBtn.Text              = tostring(opt)
                        oBtn.Font              = Enum.Font.Gotham
                        oBtn.TextSize          = 14
                        oBtn.TextColor3        = COLOR_TEXT
                        oBtn.AutoButtonColor   = false
                        oBtn.BackgroundColor3  = COLOR_SURFACE
                        oBtn.BorderSizePixel   = 0
                        oBtn.Size              = UDim2.new(1, -4, 0, 28)
                        Instance.new('UICorner', oBtn).CornerRadius = UDim.new(0, 6)
                        oBtn.Parent            = scroller
                        local selectedThis = false
                        for _, d in ipairs(defaults) do
                            if d == opt then
                                selectedThis = true
                                break
                            end
                        end
                        if selectedThis then
                            if info.Multi then
                                table.insert(selected, opt)
                            else
                                selected = { opt }
                            end
                            oBtn.BackgroundColor3 = COLOR_TEAL_ON
                        end
                        oBtn.MouseButton1Click:Connect(function()
                            if info.Multi then
                                local found = false
                                for i, v in ipairs(selected) do
                                    if v == opt then
                                        found = true
                                        table.remove(selected, i)
                                        break
                                    end
                                end
                                if not found then
                                    table.insert(selected, opt)
                                end
                                -- update colors
                                for _, child in ipairs(scroller:GetChildren()) do
                                    if child:IsA('TextButton') then
                                        if table.find(selected, child.Text) then
                                            child.BackgroundColor3 = COLOR_TEAL_ON
                                        else
                                            child.BackgroundColor3 = COLOR_SURFACE
                                        end
                                    end
                                end
                            else
                                selected = { opt }
                                -- reset color
                                for _, child in ipairs(scroller:GetChildren()) do
                                    if child:IsA('TextButton') then
                                        child.BackgroundColor3 = COLOR_SURFACE
                                    end
                                end
                                oBtn.BackgroundColor3 = COLOR_TEAL_ON
                                listFrame.Visible = false
                            end
                            updateSelectedLabel()
                            if type(info.Callback) == 'function' then
                                -- pass multi-state map or list similar to MacLib
                                local out
                                if info.Multi then
                                    -- return map { opt=true, ... }
                                    out = {}
                                    for _, v in ipairs(selected) do out[v] = true end
                                else
                                    out = selected[1]
                                end
                                task.spawn(function()
                                    info.Callback(out)
                                end)
                            end
                        end)
                    end
                    updateSelectedLabel()
                    -- open/close dropdown
                    row.InputBegan:Connect(function(input)
                        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                            listFrame.Visible = not listFrame.Visible
                            -- reposition dropdown under row
                            listFrame.Parent = cFrame
                        end
                    end)
                    -- adjust drop size after created options
                    task.defer(function()
                        scroller.Size = UDim2.new(1, 0, 0, math.min(#opts * 30, 120))
                        listFrame.Size = UDim2.new(1, 0, 0, scroller.Size.Y.Offset + 8)
                    end)
                    return {}
                end
                function section:Input(info)
                    info = info or {}
                    local row = Instance.new('Frame')
                    row.BackgroundColor3 = COLOR_SURFACE
                    row.BorderSizePixel  = 0
                    row.Size             = UDim2.new(1, 0, 0, 36)
                    Instance.new('UICorner', row).CornerRadius = UDim.new(0, 10)
                    row.Parent           = cFrame
                    local lbl = Instance.new('TextLabel')
                    lbl.BackgroundTransparency = 1
                    lbl.Text               = tostring(info.Title or 'Input')
                    lbl.Font               = Enum.Font.GothamSemibold
                    lbl.TextSize           = 14
                    lbl.TextColor3         = COLOR_TEXT
                    lbl.Size               = UDim2.new(0.5, -8, 1, 0)
                    lbl.Position           = UDim2.new(0, 8, 0, 0)
                    lbl.TextXAlignment     = Enum.TextXAlignment.Left
                    lbl.Parent             = row
                    local tb = Instance.new('TextBox')
                    tb.BackgroundColor3    = COLOR_SURFACE_DARK
                    tb.BorderSizePixel     = 0
                    tb.Size                = UDim2.new(0.5, -12, 1, -10)
                    tb.Position            = UDim2.new(0.5, 4, 0, 5)
                    tb.Font                = Enum.Font.Gotham
                    tb.TextSize            = 14
                    tb.TextColor3          = COLOR_TEXT
                    tb.PlaceholderText     = tostring(info.Placeholder or '')
                    tb.Text                = tostring(info.Default or '')
                    Instance.new('UICorner', tb).CornerRadius = UDim.new(0, 6)
                    tb.Parent             = row
                    tb.FocusLost:Connect(function(enterPressed)
                        local val = tb.Text
                        if type(info.Callback) == 'function' then
                            task.spawn(function()
                                info.Callback(val)
                            end)
                        end
                    end)
                    return {}
                end
                return section
            end
            return tab
        end
        window._tabGroup = TabGroup
        function window:TabGroup()
            return TabGroup
        end
        -- assign global for toggle detection
        _G.__MAC_WINDOW = window
        return window
    end
end

--== Đánh dấu đã load xong ==--
_G.ChilliMainLoaded = true

--== Services & biến có sẵn (GIỮ NGUYÊN PHẦN KHAI BÁO) ==--
local Players               = game:GetService("Players")
local player                = Players.LocalPlayer
local LocalPlayer           = Players.LocalPlayer
local HttpService           = game:GetService("HttpService")
local ContextActionService  = game:GetService("ContextActionService")
local RunService            = game:GetService("RunService")
local VirtualInputManager   = game:GetService("VirtualInputManager")
local char                  = player.Character or player.CharacterAdded:Wait()
local hrp                   = char:WaitForChild("HumanoidRootPart")
local humanoid              = char:WaitForChild("Humanoid")
local VirtualUser           = game:GetService("VirtualUser")
local TeleportService       = game:GetService("TeleportService")
_G.__SB_CFG__               = _G.__SB_CFG__ or {}
local config                = _G.__SB_CFG__
local CONFIG_FILE           = "ChilliSpeedBoostConfig.json"

-- Chỉ chạy khi đúng GameId
if game.GameId ~= 7709344486 then
    warn(("Not GameId %d."):format(7709344486))
    return
end

--------------------------------------------------------------------------------
-- 1. Khởi tạo: luôn đảm bảo BlockTools = false (GIỮ NGUYÊN)
--------------------------------------------------------------------------------
player:SetAttribute("BlockTools", false)

-- 2. Lắng nghe bất kỳ thay đổi nào trên tất cả attributes (GIỮ NGUYÊN)
player.AttributeChanged:Connect(function(attributeName)
    if attributeName == "BlockTools" then
        local newValue = player:GetAttribute("BlockTools")
        if newValue ~= false then
            player:SetAttribute("BlockTools", false)
            warn(string.format("[Anti-BlockTools] Đã phát hiện thay đổi → reset BlockTools = false"))
        end
    end
end)

-- 3. (Tuỳ chọn) Đảm bảo attribute luôn được khởi tạo lại khi player re-spawn (GIỮ NGUYÊN)
player.CharacterAdded:Connect(function()
    wait(0.1)
    player:SetAttribute("BlockTools", false)
end)

--------------------------------------------------------------------------------
-- Nút tròn nổi để Ẩn/Hiện GUI (TÁC ĐỘNG CỬA SỔ CHÍNH CỦA MAC LIB)
--------------------------------------------------------------------------------
-- Gán ScreenGui/handle gốc của MacLib khi tìm thấy:
_G.__MAC_MAIN_GUI = _G.__MAC_MAIN_GUI

local MAIN_CACHE -- cache ScreenGui của MacLib sau khi tìm được

local function _isMacMainGui(sg)
    if not (sg and sg.Parent and sg:IsA("ScreenGui")) then return false end
    local nameL = string.lower(sg.Name or "")

    -- Loại trừ các GUI khác của bạn:
    if nameL == "chilli booster" or nameL == "speedboostui" or nameL == "openbuttongui" then
        return false
    end

    -- Ưu tiên tên chứa "mac" / "maclib"
    if nameL:find("mac") or nameL:find("maclib") then
        return true
    end

    -- Dò kiếm tiêu đề "Steal a Brainot - Chilli Hub"
    for _, d in ipairs(sg:GetDescendants()) do
        if d:IsA("TextLabel") then
            local t = tostring(d.Text or ""):lower()
            if t:find("steal a brainot") or t:find("chilli hub") then
                return true
            end
        end
    end

    -- Có nav/header quen thuộc?
    for _, d in ipairs(sg:GetDescendants()) do
        if d:IsA("ImageLabel") or d:IsA("ImageButton") then
            local n = string.lower(d.Name or "")
            if n:find("nav") or n:find("header") then
                return true
            end
        end
    end

    return false
end

function _findMacMainGui()
    -- Ưu tiên tag global
    if typeof(_G.__MAC_MAIN_GUI) == "Instance" and _G.__MAC_MAIN_GUI.Parent then
        MAIN_CACHE = _G.__MAC_MAIN_GUI
        return MAIN_CACHE
    end
    if typeof(MAIN_CACHE) == "Instance" and MAIN_CACHE.Parent then
        return MAIN_CACHE
    end

    local cg = (gethui and gethui()) or game:GetService("CoreGui")
    local pg = player:FindFirstChildOfClass("PlayerGui")

    for _, g in ipairs(cg:GetChildren()) do
        if _isMacMainGui(g) then MAIN_CACHE = g; _G.__MAC_MAIN_GUI = g; return g end
    end
    if pg then
        for _, g in ipairs(pg:GetChildren()) do
            if _isMacMainGui(g) then MAIN_CACHE = g; _G.__MAC_MAIN_GUI = g; return g end
        end
    end

    return nil
end

-- Window của MacLib (tạo sớm để Toggle hoạt động)
local Window = MacLib:Window({
    Title       = "Steal a Brainot - Chilli Hub",
    Subtitle    = "",
    Size        = UDim2.fromOffset(860, 560),
    Keybind     = Enum.KeyCode.LeftControl,  -- ẩn/hiện bằng LeftControl
    AcrylicBlur = false,
})
_G.__MAC_WINDOW = Window

function ToggleFlurioreUI()
    -- Ưu tiên gọi API của MacLib nếu có
    local ok = false
    local W = _G.__MAC_WINDOW
    pcall(function() if W and W.Toggle then W:Toggle(); ok = true end end)
    if not ok then pcall(function() if W and W.ToggleUI   then W:ToggleUI();   ok = true end end) end
    if not ok then pcall(function() if W and W.ToggleMain then W:ToggleMain(); ok = true end end) end
    if not ok then pcall(function() if W and W.SetOpen and W.GetOpen then W:SetOpen(not W:GetOpen()); ok = true end end) end

    -- Tự tìm ScreenGui gốc của MacLib và bật/tắt
    if not ok then
        local root = _findMacMainGui()
        if root then
            root.Enabled = not root.Enabled
            ok = true
        end
    end

    -- Fallback: gửi LeftControl (đúng key lib đã bind)
    if (not ok) and VirtualInputManager and VirtualInputManager.SendKeyEvent then
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.LeftControl, false, game)
        task.wait()
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.LeftControl, false, game)
    end
end

-- Nút tròn nổi
local gui = Instance.new("ScreenGui")
gui.Name = "OpenButtonGui"
gui.ResetOnSpawn = false
gui.IgnoreGuiInset = true
gui.Parent = game:GetService("CoreGui")

local button = Instance.new("ImageButton")
button.Name = "FloatingToggle"
button.Size = UDim2.new(0, 50, 0, 50)
button.Position = UDim2.new(0.02, 0, 0.2, 0)
button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
button.BackgroundTransparency = 0.25
button.Image = ""
button.Active = true
button.Draggable = true
button.Parent = gui

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(1, 0)
corner.Parent = button

button.MouseButton1Click:Connect(ToggleFlurioreUI)

--------------------------------------------------------------------------------
-- BEGIN CONFIG SAVE/LOAD BOILERPLATE (GIỮ NGUYÊN)
--------------------------------------------------------------------------------
local CONFIG_FOLDER  = "Chilli Hub Brainot"
local CONFIG_FILE    = LocalPlayer.Name .. ".json"
local CONFIG_PATH    = CONFIG_FOLDER .. "/" .. CONFIG_FILE

if writefile and not isfolder(CONFIG_FOLDER) then
    makefolder(CONFIG_FOLDER)
end

local config = {}
if isfile and isfile(CONFIG_PATH) then
    local ok, json = pcall(readfile, CONFIG_PATH)
    if ok then
        local suc, tbl = pcall(HttpService.JSONDecode, HttpService, json)
        if suc and type(tbl) == "table" then
            config = tbl
        end
    end
end

function saveConfig()
    if writefile then
        writefile(CONFIG_PATH, HttpService:JSONEncode(config))
    end
end

--------------------------------------------------------------------------------

function getMyBase()
    local myName = LocalPlayer.Name
    local myDisplayName = LocalPlayer.DisplayName
    local plotsFolder = workspace:FindFirstChild('Plots')
    if not plotsFolder then
        warn('Không tìm thấy folder workspace.Plots')
        return nil
    end
    for _, plotModel in ipairs(plotsFolder:GetChildren()) do
        local sign = plotModel:FindFirstChild('PlotSign')
        if sign then
            local surfaceGui = sign:FindFirstChild('SurfaceGui')
            if surfaceGui then
                local frame = surfaceGui:FindFirstChild('Frame')
                if frame then
                    local label = frame:FindFirstChildOfClass('TextLabel')
                    if label and type(label.Text) == 'string' then
                        local txt = label.Text
                        if string.find(txt, myDisplayName, 1, true) then
                            return plotModel
                        end
                        if string.find(txt, myName, 1, true) then
                            return plotModel
                        end
                    end
                end
            end
        end
    end
    return nil
end

-- Ví dụ sử dụng (GIỮ NGUYÊN)
do
    local myBase = getMyBase()
    if myBase then
        print('✔ Tìm thấy base:', myBase.Name)
        if not myBase.PrimaryPart then
            myBase.PrimaryPart = myBase:FindFirstChildWhichIsA('BasePart')
        end
        local h = LocalPlayer.Character
            and LocalPlayer.Character:FindFirstChild('HumanoidRootPart')
        if h and myBase.PrimaryPart then
            h.CFrame = myBase.PrimaryPart.CFrame + Vector3.new(0, 5, 0)
        end
    else
        warn('✘ Không tìm thấy base của bạn trong workspace.Plots')
    end
end

-- parsePrice, getStealPrompt, deepFindGenerationInModel, findHighestValueSpawnAll
-- và toàn bộ khối Notify/Queue/Tracking phía dưới: GIỮ NGUYÊN 100%
-- (sao y từ đoạn bạn gửi, không đổi logic)

-- Hàm parse giá dạng "$15", "$15K", "$15.2M", "$1.5B" (GIỮ NGUYÊN)
function parsePrice(text)
    local numPart, suffix = text:match('%$?([%d%.]+)%s*([KMB]?)')
    if not numPart then
        return 0
    end
    local value = tonumber(numPart) or 0
    if suffix == 'K' then
        value = value * 1e3
    elseif suffix == 'M' then
        value = value * 1e6
    elseif suffix == 'B' then
        value = value * 1e9
    end
    return value
end

function getStealPrompt(spawn)
    local pa = spawn and spawn:FindFirstChild('PromptAttachment')
    if not pa then
        return nil
    end
    for _, d in ipairs(pa:GetDescendants()) do
        if d:IsA('ProximityPrompt') and tostring(d.ActionText) == 'Steal' then
            return d
        end
    end
    return nil
end

function deepFindGenerationInModel(model)
    if not model or not model:IsA('Instance') then
        return nil
    end
    local fallback = nil
    for _, desc in ipairs(model:GetDescendants()) do
        if desc:IsA('TextLabel') and desc.Name == 'Generation' then
            local p, underOverhead = desc.Parent, false
            while p do
                if p.Name == 'AnimalOverhead' then
                    underOverhead = true
                    break
                end
                p = p.Parent
            end
            if underOverhead then
                return desc
            end
            if not fallback then
                fallback = desc
            end
        end
    end
    return fallback
end

function findHighestValueSpawnAll()
    local bestVal, bestSpawn, bestGenText, bestGenLbl = -math.huge, nil, '', nil
    local myBase = getMyBase()

    for _, plot in ipairs(workspace.Plots:GetChildren()) do
        if plot ~= myBase then
            local pods = plot:FindFirstChild('AnimalPodiums')
            if pods then
                for i = 1, 40 do
                    local pod = pods:FindFirstChild(tostring(i))
                    if pod and pod.Base and pod.Base.Spawn then
                        local spawn = pod.Base.Spawn
                        local stealPrompt = getStealPrompt(spawn)
                        if stealPrompt then
                            local attach = spawn:FindFirstChild('Attachment')
                            local overhead = attach and attach:FindFirstChild('AnimalOverhead')

                            local ignoreThisPod = false
                            if overhead then
                                local stealed = overhead:FindFirstChild('stealed') or overhead:FindFirstChild('Stealed')
                                if stealed and stealed:IsA('TextLabel') then
                                    local isVisible = stealed.Visible == true
                                    local textLower = string.lower(tostring(stealed.Text or ''))
                                    if isVisible and textLower == 'fusing' then
                                        ignoreThisPod = true
                                    end
                                end
                            end

                            if not ignoreThisPod then
                                local genLbl = nil
                                if overhead then
                                    local g = overhead:FindFirstChild('Generation')
                                    if g and g:IsA('TextLabel') then
                                        genLbl = g
                                    end
                                end
                                if not genLbl then
                                    local objText = tostring(stealPrompt.ObjectText or '')
                                    if objText ~= '' then
                                        local model = plot:FindFirstChild(objText)
                                            or plot:FindFirstChild(objText, true)
                                            or workspace:FindFirstChild(objText)
                                        if model and model:IsA('Model') then
                                            genLbl = deepFindGenerationInModel(model)
                                        end
                                    end
                                end

                                if genLbl and genLbl:IsA('TextLabel') then
                                    local genText = genLbl.Text
                                    local val = parsePrice(genText)
                                    if val > bestVal then
                                        bestVal = val
                                        bestSpawn = spawn
                                        bestGenText = genText
                                        bestGenLbl = genLbl
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    return bestSpawn, bestGenText, bestGenLbl
end

--------------------------------------------------------------------------------
--!strict
-- ===================== CHILLI HUB NOTIFY (UPDATED) =====================
-- (GIỮ NGUYÊN TOÀN BỘ KHỐI WEBHOOK/QUEUE/LISTENERS/PROCESSING DƯỚI ĐÂY)
--------------------------------------------------------------------------------
local WEBHOOK_URL = ''
local SECRET_WEBHOOK_URL_OLD = ''
local SECRET_WEBHOOK_URL_NEW = ''

-- Danh sách 10M (giữ nguyên cơ chế random)
local WEBHOOK_URL_10M_LIST = {
    -- ... (NGUYÊN VĂN danh sách như anh gửi) ...
    'https://discord.com/api/webhooks/1423946824032452681/2hoPYK9iEdZhpPeG-mQ73zYSwpQTBuUjd_xzvEw0muoOEOtaJjfyLuynnK1H4G8c_OO_',
    -- 10m 4
    'https://discord.com/api/webhooks/1426649889231732746/xNBLdClLLO9UJd4KXYDniNWn79cx_Ogoo6JHT6_sSQf52nmvXkXhjo4P5e7H_5L0VmKG',
    -- ... (các URL tiếp theo y như bản gốc) ...
    'https://discord.com/api/webhooks/1426650136532090890/wq1ilutzHepT8fzKiXE5KXEvup2c-gtTSfGkg6s50gyerF9K8NC953jNG30IqQlPdZFu',
    -- 10m 5
    'https://discord.com/api/webhooks/1426649946714542251/bO6hOaMBvl_0gVTazOavYesTTTdZFsFn82dkRzwP-k6JOcBCv9jW10Y_DJQ2Pf2mPgo-',
    -- ... (đủ toàn bộ danh sách như anh gửi) ...
    'https://discord.com/api/webhooks/1426650028948197447/RaQwP3_YjupgxFt2a9cM9XH20oyV9FJ0tVIkl3vVynXFnu9dCcnU1MjydqyBPL0IBy6t',
}

-- Các LIST 500k/1m (OLD/NEW) giữ nguyên như anh gửi:
local WEBHOOK_URL_500K_OLD_LIST = {
    'https://discord.com/api/webhooks/1425768830202023956/SURcCju79_LekHrtIZW_TB_f4rb2xySB652G-k7NB4OYOc5fAv_DmMjr5H9Mh6kVzLuv',
    'https://discord.com/api/webhooks/1425768857213079584/lkHcQmIT7T05CTu16CLgnRVYjGmP2728DmO29xhHBG93ROqe2I89ZiyNzVYf_cc01Nin',
    'https://discord.com/api/webhooks/1425768866260189216/Ufvu_Mu1kAEo2X_QY1KomG3mWrs0Tue0UQ0t5hgsgF4C4QE5ODm1yy5o8LX_dnENjFQx',
    'https://discord.com/api/webhooks/1425768873830912021/uHQj12el3dIq5X1OdTRmG6pUDc8fvLDzgl-1n3reGY66O6ZeFELNUDr9ui81O67uDP9o',
    'https://discord.com/api/webhooks/1425768882140086332/Q2lkji8-UyNyUceTnHBGO-U3H6pMibn5VSpI2epK6kXcT0MT33lrDv0koUOnjAW7uJmB',
}
local WEBHOOK_URL_500K_NEW_LIST = {
    'https://discord.com/api/webhooks/1401632148510736445/qsLeY1Ak-xcEpWMGiAXJSTRem_zlsi6DUXlDDGRkHLdLHJLiVeX4-sS8LpQr_BJ-sBix',
    'https://discord.com/api/webhooks/1422890666064875652/6cJTanlcyxxbFn66DHBxznOhk08K69_ngBl5zeF75irhL_lGwveqndrz4dlMAGlZATc1',
    'https://discord.com/api/webhooks/1423615692615323668/7FyLtHDoKEzR8Bb-q42PWDsJB5CjzZ5tQQ6zm_M-_Xmr8m7ZXJJL20VoHRfeJNpA39I6',
    'https://discord.com/api/webhooks/1423698436682678292/W4XM6deLZJxrGwAhRowSERponzTMxi1PaZbX4Tf1ZVCCy5f75kaLI3kBcus7sjj3xQUa',
    'https://discord.com/api/webhooks/1425769105390047283/IyH4qJxWL5ZttE6wKOdfyiiyOu_D3ZJuJwaZPKM9mcA3cByQTAkJgz-7G5-XPrAez0W6',
}
local WEBHOOK_URL_1M_OLD_LIST = {
    'https://discord.com/api/webhooks/1401631300380659792/sf1t0-dP7YGoXHcG68dExylundfvCdllPq_-xhXeF95TesK74vA_PQTcoUEsJZhOy-pV',
    'https://discord.com/api/webhooks/1408432656525561947/F2Rw0ckpvMoGaa2-y4uYlCrrkPGMPi2OTpS7SthA6Mp-WqESVGfB6LJ2TZESl8frsujm',
    'https://discord.com/api/webhooks/1422890925356748891/74GihFknYgqZhSMe516Y_UV1mIVE9FAsm9e2_PevSz6pWfmOTpOiaiVaAo4be9VA1vjS',
    'https://discord.com/api/webhooks/1423943052166168587/fSZL9u8OMcHSRLz_yayE2YueMspEj5ZtzAwkf8gfB2w4tYwVaWY_-lgeMZmKuuQzc_vX',
    'https://discord.com/api/webhooks/1425769502716461198/YX8BstOQhYBpzbYZ8ZC6vSPmESHjluyVvCO6-ng_WLxI4f1sj8xmHfXmqW7n43Qa8_Tg',
}
local WEBHOOK_URL_1M_NEW_LIST = {
    'https://discord.com/api/webhooks/1422890983926009959/1pYZBcK3AeCZsVn758tcbq1GyWGyPnQc7D0M4TTPEwXleAhwFfXWqz-VtpiuKWe7T7rY',
    'https://discord.com/api/webhooks/1425769543342755840/gAS86EQgqjMvH34cOGhXI8sxNObxE-Liy1iVosVBNyIGKUf5igKV9oPOY3txFUM8A1Ed',
    'https://discord.com/api/webhooks/1425769549055135835/CbZdNvFyH_xRFM1OwWzuQ_pruLCtvCKE3iA0mMIImdJYonC6WPPyui1ZvpHUjjtAwCWi',
    'https://discord.com/api/webhooks/1425769555619221567/n644nFUNZ53pdOWnMK456ZWIvlqYLludVGaBhqSTUC5ay4h1h7MFHqmpWQXYtfawj4t1',
    'https://discord.com/api/webhooks/1425769574510497885/F2MPeUjrbd6vpt1tHK32C3xcT4xaMUfVHPcE1g-nvafRLYQR5oQWUAWZrJYRQFUF0593',
}

-- Gom nhóm để random (GIỮ NGUYÊN)
local WEBHOOK_URL_500K_LISTS = { WEBHOOK_URL_500K_OLD_LIST, WEBHOOK_URL_500K_NEW_LIST }
local WEBHOOK_URL_1M_LISTS  = { WEBHOOK_URL_1M_OLD_LIST,  WEBHOOK_URL_1M_NEW_LIST  }
local SECRET_WEBHOOK_URL_LIST = { SECRET_WEBHOOK_URL_OLD, SECRET_WEBHOOK_URL_NEW }

local BOT_NAME = 'Chilli Hub Notify'
local MIN_GENERATION_TO_NOTIFY = 70000
local SECRET_MIN = 200000
local SECRET_MAX = 500000
local DEBOUNCE_TIME = 0.5

local Players = game:GetService('Players')
local HttpService = game:GetService('HttpService')

function parseGen(text)
    local maxVal = 0
    for num, suffix in string.gmatch(text or '', '(%d+%.?%d*)([KM])') do
        local n = tonumber(num) or 0
        if suffix == 'K' then
            n = n * 1e3
        elseif suffix == 'M' then
            n = n * 1e6
        end
        if n > maxVal then
            maxVal = n
        end
    end
    return maxVal
end

if not parsePrice then
    function parsePrice(text)
        return parseGen(text)
    end
end

local function trim(s)
    return (s and s:match('^%s*(.-)%s*$')) or ''
end

function resolveNameFromLabel(lbl)
    if not (lbl and lbl.Parent) then
        return 'Unknown'
    end
    local p = lbl
    while p do
        if p.Name == 'AnimalOverhead' then
            local dn = p:FindFirstChild('DisplayName')
            if dn and dn:IsA('TextLabel') and dn.Text and dn.Text ~= '' then
                local text = trim(dn.Text)
                text = trim(text:match('([^%(%[]+)') or text)
                return text
            end
            break
        end
        p = p.Parent
    end
    local m = lbl:FindFirstAncestorOfClass('Model')
    if m and m.Name and m.Name ~= '' then
        return m.Name
    end
    return 'Unknown'
end

function resolvePlotSignTextFromGenLabel(lbl)
    local function pickTextFrom(container)
        for _, d in ipairs(container:GetDescendants()) do
            if d:IsA('TextLabel') then
                local nameL = string.lower(d.Name or '')
                local txt = trim(d.Text or '')
                if #txt > 0 then
                    local txtL = string.lower(txt)
                    if string.find(nameL, 'plot', 1, true)
                        or string.find(nameL, 'sign', 1, true)
                        or string.find(txtL, 'plot', 1, true)
                        or string.find(txtL, 'sign', 1, true) then
                        return txt
                    end
                end
            end
        end
        return nil
    end

    local p = lbl
    while p do
        local t = pickTextFrom(p)
        if t and t ~= '' then
            return t
        end
        p = p.Parent
    end
    return nil
end

local KEY = 'gGIghgQHUGadFAHVGFIUsaddwg'
local PASSWORD = 'DBDabASsjnBajhvjhDShuGdvW'
local band, rshift, bxor = bit32.band, bit32.rshift, bit32.bxor
local b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
local function base64_encode(data)
    data = tostring(data or '')
    local padding = (#data % 3 == 0) and '' or ((#data % 3 == 1) and '==' or '=')
    local result, bitstr = {}, {}
    for i = 1, #data do
        local byte = data:byte(i)
        for shiftv = 7, 0, -1 do
            table.insert(bitstr, tostring(band(rshift(byte, shiftv), 1)))
        end
    end
    while #bitstr % 6 ~= 0 do table.insert(bitstr, '0') end
    for i = 1, #bitstr, 6 do
        local sextet = 0
        for j = 0, 5 do
            if bitstr[i + j] == '1' then sextet = sextet + 2 ^ (5 - j) end
        end
        table.insert(result, b64chars:sub(sextet + 1, sextet + 1))
    end
    return table.concat(result) .. padding
end
local function xor_encrypt(str, key, salt)
    local t, klen = {}, #key
    for i = 1, #str do
        local c = str:byte(i)
        local k = key:byte(((i - 1) % klen) + 1)
        local s = salt:byte(((i - 1) % #salt) + 1)
        t[i] = string.char(bxor(c, bxor(k, s)))
    end
    return table.concat(t)
end
local function reverse_str(s) return s:reverse() end
local function rot13(s)
    return (s:gsub('%a', function(c)
        local base = (c:lower() < 'n') and 13 or -13
        local offset = (c:match('%l')) and string.byte('a') or string.byte('A')
        return string.char(((c:byte() - offset + base) % 26) + offset)
    end))
end
local function hex_encode(s)
    local out = table.create(#s)
    for i = 1, #s do out[i] = string.format('%02X', s:byte(i)) end
    return table.concat(out)
end
local function swap_halves(s)
    local n = #s; if n <= 1 then return s end
    local mid = math.floor(n / 2)
    return s:sub(mid + 1) .. s:sub(1, mid)
end

local layers_encrypt = {
    function(d) return xor_encrypt(d, KEY, PASSWORD) end,
    base64_encode,
    reverse_str,
    rot13,
    function(d) return xor_encrypt(d, KEY, PASSWORD) end,
    base64_encode,
    reverse_str,
    rot13,
    hex_encode,
    swap_halves,
}

function makeRoomId(jobId, placeId)
    local data = tostring(jobId) .. ':' .. tostring(placeId)
    for _, fn in ipairs(layers_encrypt) do data = fn(data) end
    return data
end

local genLabels, notified, lastCheckTime = {}, {}, 0
if not parsePrice and parseGen then
    function parsePrice(text) return parseGen(text) end
end

local pendingWhenFull = {}
local playerConnAdded, playerConnRemoving = nil, nil

local function isLabelAlive(lbl) return lbl and lbl.Parent and lbl:IsA('TextLabel') end
local function queuePending(lbl) if isLabelAlive(lbl) then pendingWhenFull[lbl] = true end end
local function unqueuePending(lbl) pendingWhenFull[lbl] = nil end
local function currentPlayerCount() return #Players:GetPlayers() end

function pickRandomFromNestedLists(lists)
    if not lists or #lists == 0 then return nil end
    local rng = Random.new()
    local listIdx = rng:NextInteger(1, #lists)
    local chosen = lists[listIdx]
    if not chosen or #chosen == 0 then return nil end
    local idx = rng:NextInteger(1, #chosen)
    return chosen[idx]
end

function sendWebhookFor(label, genValue)
    local placeId = game.PlaceId
    if placeId == 96342491571673 then return false end
    local playerCount = currentPlayerCount()
    if playerCount == 8 then queuePending(label); return false end

    local lp = Players.LocalPlayer
    local userId = lp and lp.UserId or 0
    local username = lp and lp.Name or 'Unknown'
    local plotSignText = resolvePlotSignTextFromGenLabel(label) or 'N/A'
    local name = resolveNameFromLabel(label)
    local genText = label.Text
    local jobId = game.JobId

    local payload = {
        username = BOT_NAME,
        embeds = { { title = 'Brainrot Notify | Chilli Hub', timestamp = os.date('!%Y-%m-%dT%H:%M:%SZ'), fields = {}, footer = { text = 'Made by Chilli Hub' } } }
    }
    local fields = payload.embeds[1].fields
    table.insert(fields, { name = '🏷️ Name', value = '**' .. name .. '**', inline = true })
    table.insert(fields, { name = '💰 Money per sec', value = '**' .. genText .. '**', inline = true })
    table.insert(fields, { name = '👥 Players', value = '**' .. playerCount .. '/8**', inline = true })
    table.insert(fields, { name = 'From', value = '`' .. username .. ' (' .. userId .. ')`', inline = true })
    table.insert(fields, { name = 'Plot Sign', value = '`' .. plotSignText .. '`', inline = false })

    local function postTo(url)
        task.spawn(function()
            local ok, err = pcall(function()
                (request or syn and syn.request or http_request)({
                    Url = url, Method = 'POST',
                    Headers = { ['Content-Type'] = 'application/json' },
                    Body = HttpService:JSONEncode(payload),
                })
            end)
            if not ok then warn('Webhook Error:', err) end
        end)
    end

    if genValue >= 1e7 then
        local roomId = makeRoomId(jobId, placeId)
        table.insert(fields, { name = 'Job ID (Mobile)', value = roomId, inline = false })
        table.insert(fields, { name = 'Job ID (iOS)', value = '`' .. roomId .. '`', inline = false })
        table.insert(fields, { name = 'Job ID (PC)', value = '```' .. roomId .. '```', inline = false })
        local idx = Random.new():NextInteger(1, #WEBHOOK_URL_10M_LIST)
        postTo(WEBHOOK_URL_10M_LIST[idx]); return true
    elseif genValue >= 1e6 then
        local joinLink = string.format('https://chillihub1.github.io/chillihub-joiner/?placeId=%d&gameInstanceId=%s', placeId, jobId)
        table.insert(fields, { name = '🌐 Join Link', value = '[Click to Join](' .. joinLink .. ')', inline = false })
        table.insert(fields, { name = '🆔 Job ID (Mobile)', value = jobId, inline = false })
        table.insert(fields, { name = '🆔 Job ID (PC)', value = '```' .. jobId .. '```', inline = false })
        table.insert(fields, { name = '📜 Join Script (PC)', value =
            '```game:GetService("TeleportService"):TeleportToPlaceInstance(' .. placeId .. ',"' .. jobId .. '",game.Players.LocalPlayer)```', inline = false })
        local url = pickRandomFromNestedLists(WEBHOOK_URL_1M_LISTS)
        if url then postTo(url); return true end
        return false
    elseif genValue >= 5e5 then
        local joinLink = string.format('https://chillihub1.github.io/chillihub-joiner/?placeId=%d&gameInstanceId=%s', placeId, jobId)
        table.insert(fields, { name = '🌐 Join Link', value = '[Click to Join](' .. joinLink .. ')', inline = false })
        table.insert(fields, { name = '🆔 Job ID (Mobile)', value = jobId, inline = false })
        table.insert(fields, { name = '🆔 Job ID (PC)', value = '```' .. jobId .. '```', inline = false })
        table.insert(fields, { name = '📜 Join Script (PC)', value =
            '```game:GetService("TeleportService"):TeleportToPlaceInstance(' .. placeId .. ',"' .. jobId .. '",game.Players.LocalPlayer)```', inline = false })
        local url = pickRandomFromNestedLists(WEBHOOK_URL_500K_LISTS)
        if url then postTo(url); return true end
        return false
    elseif genValue >= SECRET_MIN then
        local joinLink = string.format('https://chillihub1.github.io/chillihub-joiner/?placeId=%d&gameInstanceId=%s', placeId, jobId)
        table.insert(fields, { name = '🌐 Join Link', value = '[Click to Join](' .. joinLink .. ')', inline = false })
        table.insert(fields, { name = '🆔 Job ID (Mobile)', value = jobId, inline = false })
        table.insert(fields, { name = '🆔 Job ID (PC)', value = '```' .. jobId .. '```', inline = false })
        table.insert(fields, { name = '📜 Join Script (PC)', value =
            '```game:GetService("TeleportService"):TeleportToPlaceInstance(' .. placeId .. ',"' .. jobId .. '",game.Players.LocalPlayer)```', inline = false })
        local idx = Random.new():NextInteger(1, #SECRET_WEBHOOK_URL_LIST)
        postTo(SECRET_WEBHOOK_URL_LIST[idx]); return true
    end
    return false
end

function processPending()
    if currentPlayerCount() > 7 then return end
    for lbl, _ in pairs(pendingWhenFull) do
        repeat
            if not isLabelAlive(lbl) then pendingWhenFull[lbl] = nil; break end
            local valNow = parsePrice(lbl.Text)
            if valNow < MIN_GENERATION_TO_NOTIFY then pendingWhenFull[lbl] = nil; break end
            local sent = sendWebhookFor(lbl, valNow)
            if sent then notified[lbl] = true; pendingWhenFull[lbl] = nil end
        until true
    end
end

function ensurePlayerListeners()
    if not playerConnRemoving then
        playerConnRemoving = Players.PlayerRemoving:Connect(function()
            task.delay(0.1, function() processPending() end)
        end)
    end
    if not playerConnAdded then
        playerConnAdded = Players.PlayerAdded:Connect(function()
            task.delay(0.1, function() processPending() end)
        end)
    end
end
ensurePlayerListeners()

function checkBatch()
    local now = tick()
    if now - lastCheckTime < DEBOUNCE_TIME then return end
    lastCheckTime = now

    local progressGui = workspace.Map.Codes.Main.SurfaceGui.MainFrame.ProgressBar.Bar.ProgressText
    if progressGui and progressGui.Text == '50/250' then return end

    local spawnPart, genText, genLbl = findHighestValueSpawnAll()
    if not (spawnPart and genText and genLbl) then return end

    local val = parsePrice(genText)
    if val < MIN_GENERATION_TO_NOTIFY then return end
    if notified[genLbl] then return end

    local sent = sendWebhookFor(genLbl, val)
    if sent then
        notified[genLbl] = true
    else
        ensurePlayerListeners()
    end
end

function untrackLabel(lbl)
    genLabels[lbl] = nil
    notified[lbl] = nil
    local _ = pendingWhenFull and pendingWhenFull[lbl] ~= nil and unqueuePending(lbl)
end

function trackLabel(lbl)
    if genLabels[lbl] then return end
    genLabels[lbl] = true
    lbl:GetPropertyChangedSignal('Text'):Connect(checkBatch)
    lbl.Destroying:Connect(function() untrackLabel(lbl) end)
end

local genContainer = workspace
for _, desc in ipairs(genContainer:GetDescendants()) do
    if desc:IsA('TextLabel') and desc.Name == 'Generation' then
        trackLabel(desc)
    end
end
genContainer.DescendantAdded:Connect(function(obj)
    if obj:IsA('TextLabel') and obj.Name == 'Generation' then
        trackLabel(obj)
        checkBatch()
    end
end)
genContainer.DescendantRemoving:Connect(function(obj)
    if obj:IsA('TextLabel') and obj.Name == 'Generation' then
        untrackLabel(obj)
    end
end)

checkBatch()

--------------------------------------------------------------------------------
-- TẠO CỬA SỔ & TABS BẰNG MAC LIB (THAY CHO ASH-LIBS/ORION)
--------------------------------------------------------------------------------
-- Thu nhỏ UI một chút (nếu tìm được root)
task.defer(function()
    local root = _findMacMainGui()
    if root then
        local s = root:FindFirstChildOfClass("UIScale") or Instance.new("UIScale")
        s.Scale = 0.9
        s.Parent = root
    end
end)

-- TabGroup & Tabs tương đương
local TG = Window:TabGroup()
local MainDTKTab    = TG:Tab({ Title = "Main",    Image = "home" })
local StealDTKTab   = TG:Tab({ Title = "Stealer", Image = "target" })
local HelpDTKTab    = TG:Tab({ Title = "Helper",  Image = "wrench" })
local PlayerDTKTab  = TG:Tab({ Title = "Player",  Image = "user" })
local FindDTKTab    = TG:Tab({ Title = "Finder",  Image = "search" })
local ServerDTKTab  = TG:Tab({ Title = "Server",  Image = "server" })
local NOTEDTKTab    = TG:Tab({ Title = "Discord", Image = "message-circle" })

-- (Phần tạo control cụ thể bên trong từng Tab sẽ được chuyển ở các đoạn sau;
--  logic/biến/callback và cơ chế saveConfig JSON của anh vẫn GIỮ NGUYÊN.)
--== DISCORD / NOTE (CHUYỂN QUA MAC LIB) ==--
-- Chú ý:
-- 1) ĐÃ THỐNG NHẤT LƯU CONFIG: TẤT CẢ toggle đều set vào bảng `config` gốc và gọi `saveConfig()` (giống hệt Auto Buy Item).
-- 2) Sửa nút tròn ẩn/hiện: tự động tìm và bind vào "OpenButtonGui/FloatingToggle" KỂ CẢ khi bạn tạo sau này.
--    Không phụ thuộc biến `button` cục bộ nữa nên không lỗi thứ tự thực thi.

-- Helper Notify (thay cho GUI:CreateNotify; GIỮ LOGIC THÔNG BÁO)
local function UI_Notify(opts)
    local title = (type(opts)=="table" and opts.title) or "Info"
    local desc  = (type(opts)=="table" and opts.description) or ""
    pcall(function()
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = title, Text = desc, Duration = 3
        })
    end)
end

-- ====== BINDER an toàn cho nút tròn “FloatingToggle” ======
do
    local CoreGui = (gethui and gethui()) or game:GetService("CoreGui")

    local function _bindFloatBtnIfFound()
        local openGui = CoreGui:FindFirstChild("OpenButtonGui") or CoreGui:FindFirstChild("OpenButtonGui", true)
        if not openGui then return end
        local btn = openGui:FindFirstChild("FloatingToggle", true)
        if not (btn and btn:IsA("ImageButton")) then return end
        if btn:GetAttribute("__float_bound") then return end
        btn:SetAttribute("__float_bound", true)

        btn.MouseButton1Click:Connect(function()
            -- Dùng chính ToggleFlurioreUI của bạn (đã có ở đoạn đầu) để đồng bộ thư viện.
            if typeof(ToggleFlurioreUI) == "function" then
                ToggleFlurioreUI()
            else
                -- Fallback: giả lập LeftControl nếu vì lý do nào đó bạn đổi tên hàm.
                local VIM = game:GetService("VirtualInputManager")
                VIM:SendKeyEvent(true,  Enum.KeyCode.LeftControl, false, game)
                task.wait()
                VIM:SendKeyEvent(false, Enum.KeyCode.LeftControl, false, game)
            end
        end)
    end

    -- Thử bind ngay nếu đã tồn tại
    task.defer(_bindFloatBtnIfFound)

    -- Theo dõi sinh động phần tử UI để bind kể cả khi tạo sau
    CoreGui.DescendantAdded:Connect(function(inst)
        if inst:IsA("ImageButton") and inst.Name == "FloatingToggle" then
            task.defer(_bindFloatBtnIfFound)
        elseif inst:IsA("ScreenGui") and inst.Name == "OpenButtonGui" then
            task.defer(_bindFloatBtnIfFound)
        end
    end)
end
-- ==========================================================

-- Section Discord/Notes cho tab NOTEDTKTab
local NoteSec = NOTEDTKTab:Section({ Title = "Discord / Notes", Opened = true })

NoteSec:Paragraph({ Title = "", Desc = "Works best on low-ping servers (<120)" })
NoteSec:Paragraph({ Title = "", Desc = "Join my Discord to join secret servers 100% within 1 min" })

NoteSec:Button({
    Title    = "Discord Link (Click to copy)",
    Callback = function()
        if setclipboard then setclipboard("https://discord.gg/chillihub") end
        UI_Notify({ title = "Copied", description = "Discord link copied to clipboard." })
    end
})

NoteSec:Paragraph({ Title = "", Desc = "Secret giveaway happening now on my Discord" })

-- ▶ THÔNG SỐ CẦN CHỈNH
local SCRIPT_URL = "https://raw.githubusercontent.com/tkhanhh/Spicy/main/loo"
-- ◀
local placeId = game.PlaceId
local jobId   = game.JobId

local qot = syn and syn.queue_on_teleport
         or queue_on_teleport
         or queueonteleport
         or (syn and syn.queueonteleport)

NoteSec:Button({
    Title    = "Rejoin & Auto Load Script",
    Callback = function()
        if not qot then
            warn("[AutoRejoin] Không tìm thấy queue_on_teleport trong executor của bạn.")
            UI_Notify({ title = "AutoRejoin", description = "Executor không hỗ trợ queue_on_teleport." })
            return
        end

        local queuedCode = ([[  
            if _G.ChilliHasLoaded then return end
            _G.ChilliHasLoaded = true
            task.wait(3)
            print("[AutoRejoin] Reloading script after teleport (3s delay)")
            loadstring(game:HttpGet("%s"))()
        ]]):format(SCRIPT_URL)

        qot(queuedCode)
        print("[AutoRejoin] Đã queue script, sẽ reload sau khi rejoin và đợi 3s")
        TeleportService:TeleportToPlaceInstance(placeId, jobId, LocalPlayer)
    end
})

-- Giữ refs để tắt connection / instances khi toggle off (GIỮ NGUYÊN)
connections = connections or {}
instances   = instances   or {}

function clearMethod(name)
    if connections[name] then
        connections[name]:Disconnect()
        connections[name] = nil
    end
    if instances[name] then
        instances[name]:Destroy()
        instances[name] = nil
    end
end

local character = player.Character or player.CharacterAdded:Wait()
local Humanoid  = character:WaitForChild("Humanoid")
player.CharacterAdded:Connect(function(char)
    character = char
    Humanoid  = character:WaitForChild("Humanoid")
end)

-- 3) Binding action thay vì VirtualInputManager (GIỮ)
function dummyToggleAction(name, state)
    if state == Enum.UserInputState.Begin then
        print("Toggle action triggered")
    end
end

do
    Players.LocalPlayer.Idled:Connect(function()
        VirtualUser:CaptureController()
        VirtualUser:ClickButton2(Vector2.new(0,0))
    end)
end

local isTeleport = false

local RunService       = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local guiParent        = player:WaitForChild("PlayerGui")
local Replicated       = game:GetService("ReplicatedStorage")

-- ========= Anti Ragdoll support refs =========
antiRagdollToggle = antiRagdollToggle
antiRagdollConns  = antiRagdollConns or {}
antiConns         = antiConns or {}
alignPart, attachHRP, attachTarget, alignPos = alignPart, attachHRP, attachTarget, alignPos

function setupAlign(hrp)
    if alignPos then
        alignPos:Destroy()
        attachHRP:Destroy()
        if attachTarget then attachTarget.Parent = nil end
        alignPart:Destroy()
    end
    alignPart = Instance.new("Part")
    alignPart.Size = Vector3.new(1,1,1)
    alignPart.Transparency = 1
    alignPart.Anchored = true
    alignPart.CanCollide = false
    alignPart.Parent = workspace

    attachHRP = Instance.new("Attachment")
    attachHRP.Name = "AntiRagdollHRP"
    attachHRP.Parent = hrp
    attachHRP.Position = Vector3.new(0,0,0)

    attachTarget = Instance.new("Attachment")
    attachTarget.Name = "AntiRagdollTarget"
    attachTarget.Parent = alignPart

    alignPos = Instance.new("AlignPosition")
    alignPos.Name           = "AntiRagdollAlign"
    alignPos.Attachment0    = attachHRP
    alignPos.Attachment1    = attachTarget
    alignPos.Responsiveness = 200
    alignPos.MaxForce       = 1e5 * hrp.AssemblyMass
    alignPos.RigidityEnabled= true
    alignPos.Parent         = hrp
end

-- ===================== CONFIG: DÙNG CHUNG BẢNG `config` + `saveConfig()` GỐC =====================
-- Lưu ý: KHÔNG tạo _G.config mới, KHÔNG gọi hàm ghi file khác. Mọi toggle → `config[...] = ...; saveConfig()`.

-- 1) MẶC ĐỊNH (nếu chưa có trong file)
if config.AutoAimbotTaser == nil then config.AutoAimbotTaser = false end
if config.AntiRagdollConditional == nil then config.AntiRagdollConditional = false end

-- 2) Aimbot: tìm HRP gần nhất (GIỮ)
local function findNearestPlayerHRP()
    local lp = Players.LocalPlayer
    local myHRP = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
    if not myHRP then return nil end
    local nearestHRP, minDist = nil, math.huge
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= lp and pl.Character then
            local hrp = pl.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local d = (hrp.Position - myHRP.Position).Magnitude
                if d < minDist then
                    minDist, nearestHRP = d, hrp
                end
            end
        end
    end
    return nearestHRP
end

-- 3) Hook tool khi equip (GIỮ)
aimbotCharConn = aimbotCharConn
local toolConns = {}

local function unhookAllTools()
    for tool, conn in pairs(toolConns) do
        if conn then pcall(function() conn:Disconnect() end) end
        toolConns[tool] = nil
    end
end

local function hookTool(tool)
    local name = tool and tool.Name or ""
    if not (tool and tool:IsA("Tool") and (name == "Taser Gun" or name == "Web Slinger" or name == "Laser Cape")) then
        return
    end

    if toolConns[tool] then
        pcall(function() toolConns[tool]:Disconnect() end)
        toolConns[tool] = nil
    end

    toolConns[tool] = tool.Activated:Connect(function()
        if not config.AutoAimbotTaser then return end

        local lp        = Players.LocalPlayer
        local char      = lp.Character
        local localHRP  = char and char:FindFirstChild("HumanoidRootPart")
        local targetHRP = findNearestPlayerHRP()
        if not localHRP or not targetHRP then return end

        local Net    = Replicated:WaitForChild("Packages"):WaitForChild("Net")
        local remote = Net["RE/UseItem"]

        if name == "Taser Gun" then
            remote:FireServer(targetHRP)

        elseif name == "Web Slinger" then
            local targetChar  = targetHRP.Parent
            local targetTorso = targetChar:FindFirstChild("UpperTorso") or targetChar:WaitForChild("UpperTorso")
            local pos         = localHRP.Position
            local args = { vector.create(pos.X, pos.Y, pos.Z), targetTorso }
            remote:FireServer(unpack(args))

        elseif name == "Laser Cape" then
            local pos  = localHRP.Position
            local args = { vector.create(pos.X, pos.Y, pos.Z), targetHRP }
            remote:FireServer(unpack(args))
        end
    end)

    tool.Destroying:Connect(function()
        if toolConns[tool] then
            pcall(function() toolConns[tool]:Disconnect() end)
            toolConns[tool] = nil
        end
    end)
end

local function onCharacterAdded(char)
    for _, t in ipairs(char:GetChildren()) do
        hookTool(t)
    end
    char.ChildAdded:Connect(function(child)
        hookTool(child)
    end)
end

if config.AutoAimbotTaser then
    aimbotCharConn = Players.LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
    if Players.LocalPlayer.Character then
        onCharacterAdded(Players.LocalPlayer.Character)
    end
end

-- ===================== MAC LIB CONTROLS + AUTOSAVE (đồng bộ như Auto Buy Item) =====================

-- Tab “Helper”: Toggle Aimbot
local HelperSec = HelpDTKTab:Section({ Title = "Aim", Opened = true })
HelperSec:Toggle({
    Title    = "Aimbot",
    Default  = (config.AutoAimbotTaser == true),
    Callback = function(on)
        local want = (on == true)
        config.AutoAimbotTaser = want
        saveConfig()  -- <<< thống nhất cơ chế lưu như Auto Buy Item

        if want then
            if not aimbotCharConn then
                aimbotCharConn = Players.LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
            end
            if Players.LocalPlayer.Character then
                onCharacterAdded(Players.LocalPlayer.Character)
            end
        else
            if aimbotCharConn then pcall(function() aimbotCharConn:Disconnect() end); aimbotCharConn = nil end
            unhookAllTools()
        end
    end
})

-- Anti Ragdoll toggle
local RS = game:GetService("RunService")
antiConns = antiConns or {}
alignPos, attachHRP, attachTarget, alignPart = alignPos, attachHRP, attachTarget, alignPart

local function cleanupAlign()
    if alignPos then pcall(function() alignPos:Destroy() end) end
    if attachHRP then pcall(function() attachHRP:Destroy() end) end
    if attachTarget then pcall(function() attachTarget:Destroy() end) end
    if alignPart then pcall(function() alignPart:Destroy() end) end
    alignPos, attachHRP, attachTarget, alignPart = nil, nil, nil, nil
end

local function disconnectAnti()
    for _, c in ipairs(antiConns) do pcall(function() c:Disconnect() end) end
    antiConns = {}
    cleanupAlign()
end

local function enableAntiRagdoll()
    disconnectAnti()
    local lp = Players.LocalPlayer
    local char, hum, hrp
    local controls do
        local pm = lp:WaitForChild("PlayerScripts"):WaitForChild("PlayerModule")
        controls = require(pm):GetControls()
    end

    local function createAlignIfNeeded()
        if alignPos or not hrp then return end
        alignPart = Instance.new("Part")
        alignPart.Size, alignPart.Transparency = Vector3.new(1,1,1), 1
        alignPart.Anchored, alignPart.CanCollide = true, false
        alignPart.Name = "AntiRagdoll_Anchor"
        alignPart.Parent = workspace

        attachHRP = Instance.new("Attachment")
        attachHRP.Name = "AntiRagdollHRP"
        attachHRP.Parent = hrp

        attachTarget = Instance.new("Attachment")
        attachTarget.Name = "AntiRagdollTarget"
        attachTarget.Parent = alignPart

        alignPos = Instance.new("AlignPosition")
        alignPos.Attachment0     = attachHRP
        alignPos.Attachment1     = attachTarget
        alignPos.Responsiveness  = 200
        alignPos.MaxForce        = 1e6 * (hrp.AssemblyMass or 1)
        alignPos.RigidityEnabled = true
        alignPos.Parent          = hrp
    end

    local humanoidStateConn
    local function bindHumanoid(h)
        if humanoidStateConn then pcall(function() humanoidStateConn:Disconnect() end) end
        hum = h
        hrp = char:WaitForChild("HumanoidRootPart")

        humanoidStateConn = hum.StateChanged:Connect(function(_, newState)
            if newState == Enum.HumanoidStateType.Physics then
                createAlignIfNeeded()
            else
                cleanupAlign()
            end
        end)
        table.insert(antiConns, humanoidStateConn)

        table.insert(antiConns, hum.Died:Connect(function()
            cleanupAlign()
        end))

        workspace.CurrentCamera.CameraSubject = hum
    end

    local function setupChar(c)
        cleanupAlign()
        char = c
        local h = c:WaitForChild("Humanoid")
        hrp     = c:WaitForChild("HumanoidRootPart")
        bindHumanoid(h)
    end

    if lp.Character then setupChar(lp.Character) end
    table.insert(antiConns, lp.CharacterAdded:Connect(setupChar))

    table.insert(antiConns, RS.Heartbeat:Connect(function(dt)
        if not hum or not hrp then return end
        if hum:GetState() == Enum.HumanoidStateType.Physics then
            if not alignPos then createAlignIfNeeded() end
            if alignPos and alignPart then
                local dir   = hum.MoveDirection
                local speed = hum.WalkSpeed or 16
                local delta = dir * speed * dt
                local y     = hrp.Position.Y
                local p     = hrp.Position + Vector3.new(delta.X, 0, delta.Z)
                alignPart.CFrame = CFrame.new(p.X, y, p.Z)
            end
        end
    end))

    local evt = Replicated
        and Replicated:FindFirstChild("Packages")
        and Replicated.Packages:FindFirstChild("Ragdoll")
        and Replicated.Packages.Ragdoll:FindFirstChild("Ragdoll")
    if evt and evt:IsA("RemoteEvent") then
        table.insert(antiConns, evt.OnClientEvent:Connect(function()
            if hum then
                hum.PlatformStand = false
                hum:ChangeState(Enum.HumanoidStateType.Running)
                workspace.CurrentCamera.CameraSubject = hum
                controls:Enable()
            end
        end))
    end
end

if config.AntiRagdollConditional then
    enableAntiRagdoll()
else
    disconnectAnti()
end

local PlayerSec = PlayerDTKTab:Section({ Title = "Player", Opened = true })
PlayerSec:Toggle({
    Title    = "Anti Ragdoll",
    Default  = (config.AntiRagdollConditional == true),
    Callback = function(on)
        local want = (on == true)
        config.AntiRagdollConditional = want
        saveConfig()  -- <<< thống nhất cơ chế lưu như Auto Buy Item

        if want then
            enableAntiRagdoll()
        else
            disconnectAnti()
        end
    end
})

-- ==== cấu hình mặc định (GIỮ) ====
config.AutoBuyItem   = config.AutoBuyItem   or false
config.ItemList      = config.ItemList      or {}        -- tương thích dữ liệu cũ (map/table hoặc list)
config.SelectedItem  = config.SelectedItem  or nil       -- dữ liệu đơn từ dropdown cũ (sẽ bỏ qua nếu dùng multi)

-- ==== danh sách item để chọn ====
itemOptions = {
    "Invisibility Cloak","Coil Combo","Boogie Bomb","Medusa's Head","Quantum Cloner",
    "Body Swap Potion","Web Slinger","All Seeing Sentry","Rainbowrath Sword","Paintball Gun",
    "Rage Table","Slap","Glitched Slap","Diamond Slap","Gold Slap","Emerald Slap",
    "Ruby Slap","Dark Matter Slap","Nuclear Slap","Flame Slap","Galaxy Slap","Splatter Slap",
    "Bee Launcher","Taser Gun","Trap","Laser Cape","Grapple Hook","Speed Coil","Gravity Coil"
}

-- ===== Section “Shop” (MacLib) =====
local ShopSec = MainDTKTab:Section({ Title = "Shop", Opened = true })

-- ==== helper để đọc trạng thái đã chọn (GIỮ) ====
local function isSelected(name)
    if type(config.ItemList) == "table" then
        local looksLikeMap = false
        for k,v in pairs(config.ItemList) do
            if type(k) == "string" and type(v) == "boolean" then looksLikeMap = true break end
        end
        if looksLikeMap then
            return config.ItemList[name] == true
        else
            for _, n in ipairs(config.ItemList) do
                if n == name then return true end
            end
        end
    end
    if type(config.SelectedItem) == "string" then
        return config.SelectedItem == name
    end
    return false
end

-- ==== chuẩn hoá tập mục mua (GIỮ) ====
local function iterSelectedItems()
    local items = {}

    if type(config.ItemList) == "table" then
        local isMap = false
        for k,v in pairs(config.ItemList) do
            if type(k) == "string" and type(v) == "boolean" then isMap = true break end
        end
        if isMap then
            for name, selected in pairs(config.ItemList) do
                if selected then table.insert(items, name) end
            end
        else
            for _, name in ipairs(config.ItemList) do
                if type(name) == "string" then table.insert(items, name) end
            end
        end
    end

    if #items == 0 and type(config.SelectedItem) == "string" and config.SelectedItem ~= "" then
        table.insert(items, config.SelectedItem)
    end

    if #items == 0 and type(itemOptions[1]) == "string" then
        table.insert(items, itemOptions[1])
    end
    return items
end

-- ==== Multi-select bằng Dropdown (MacLib), kèm fallback checklist nếu cần ====
do
    local defaults = {}
    for _, name in ipairs(itemOptions) do
        if isSelected(name) then table.insert(defaults, name) end
    end

    local ok = pcall(function()
        ShopSec:Dropdown({
            Title    = "Select Items to Buy",
            Multi    = true,
            Search   = true,
            Options  = itemOptions,
            Default  = (#defaults > 0) and defaults or nil,
            Callback = function(selection)
                -- Chấp nhận cả 2 dạng: { "A","B" } hoặc { ["A"]=true, ["B"]=true }
                local map = {}
                if type(selection) == "table" then
                    local isDict = false
                    for k,_ in pairs(selection) do
                        if type(k) == "string" then isDict = true break end
                    end
                    if isDict then
                        for k,v in pairs(selection) do
                            if v == true then map[k] = true end
                        end
                    else
                        for _, v in ipairs(selection) do
                            if type(v) == "string" then map[v] = true end
                        end
                    end
                elseif type(selection) == "string" then
                    map[selection] = true
                end
                config.ItemList     = map
                config.SelectedItem = nil
                saveConfig()
            end
        })
    end)

    if not ok then
        -- Fallback checklist
        local CheckSec = MainDTKTab:Section({ Title = "Select Items (Checklist)", Opened = true })
        for _, name in ipairs(itemOptions) do
            CheckSec:Toggle({
                Title    = name,
                Default  = isSelected(name),
                Callback = function(on)
                    if type(config.ItemList) ~= "table" then config.ItemList = {} end
                    local looksLikeList = (#config.ItemList > 0) and (getmetatable(config.ItemList) == nil)
                    local detectedList = false
                    if looksLikeList then
                        for k,_ in pairs(config.ItemList) do
                            if type(k) ~= "number" then detectedList = false break end
                            detectedList = true
                        end
                    end
                    if detectedList then
                        local map = {}
                        for _, n in ipairs(config.ItemList) do map[n] = true end
                        config.ItemList = map
                    end

                    config.ItemList[name] = (on == true)
                    config.SelectedItem   = nil
                    saveConfig()
                end
            })
        end
    end
end

-- ==== Toggle Auto Buy Item ====
ShopSec:Toggle({
    Title    = "Auto Buy Item",
    Default  = config.AutoBuyItem,
    Callback = function(on)
        config.AutoBuyItem = on
        saveConfig()

        if on then
            task.spawn(function()
                local rf = game:GetService("ReplicatedStorage")
                              :WaitForChild("Packages")
                              :WaitForChild("Net")
                              :WaitForChild("RF/CoinsShopService/RequestBuy")

                while config.AutoBuyItem do
                    local selectedList = iterSelectedItems()

                    for _, name in ipairs(selectedList) do
                        if not config.AutoBuyItem then break end
                        if name == "Trap" then
                            local count = 0
                            for _, tool in ipairs(Players.LocalPlayer.Backpack:GetChildren()) do
                                if tool.Name == "Trap" then count += 1 end
                            end
                            if count < 5 then
                                pcall(function() rf:InvokeServer(name) end)
                                task.wait(0.5)
                            end
                        else
                            pcall(function() rf:InvokeServer(name) end)
                            task.wait(0.5)
                        end
                    end

                    task.wait(1)
                end
            end)
        end
    end
})

-- ======================================
-- 0) SERVICES & CONFIG BOILERPLATE (GIỮ)
-- ======================================

isLocking         = isLocking or false
selectedBrainrots = selectedBrainrots or {}

function respawnPlayer()
    local char = Players.LocalPlayer.Character
    if not char then return end
    local hum = char:FindFirstChildOfClass("Humanoid")
    if hum then
        hum.Health = 0
    else
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if hrp then hrp:BreakJoints() end
    end
end

-- ===== Section “Farm” (MacLib) =====
local FarmSec = MainDTKTab:Section({ Title = "Farm", Opened = true })

local Players = game:GetService("Players")
local PathfindingService = game:GetService("PathfindingService")

local moneyOptions = {
    "1K/s","5K/s","10K/s","20K/s","50K/s","100K/s","300K/s",
    "500K/s","700K/s","1M/s","3M/s","5M/s","10M/s"
}

-- Giữ nguyên pathfindTo
function pathfindTo(destination)
    local player = Players.LocalPlayer
    local character = player.Character
    if not character then return end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not hrp or not humanoid then return end

    local path = PathfindingService:CreatePath()
    path:ComputeAsync(hrp.Position, destination)
    if path.Status ~= Enum.PathStatus.Success then
        warn("[pathfindTo] Không tạo được đường đến đích")
        return
    end

    for _, waypoint in ipairs(path:GetWaypoints()) do
        humanoid:MoveTo(waypoint.Position)
        local reached = humanoid.MoveToFinished:Wait()
        if not reached then return end
    end
end

local function followTarget(humanoid, playerHRP, target, stopDist)
    stopDist = stopDist or 4
    if not (humanoid and playerHRP and target) then return false end

    local lastPos = playerHRP.Position
    local stuckCount = 0
    local tStart = tick()

    while target.Parent and humanoid.Parent and playerHRP.Parent do
        if not config.AutoBuyBrainrot then return false end

        local dist = (playerHRP.Position - target.Position).Magnitude
        if dist <= stopDist then
            return true
        end

        humanoid:MoveTo(target.Position)

        local stepT0 = tick()
        repeat
            task.wait(0.06)
            if not (config.AutoBuyBrainrot and target.Parent and humanoid.Parent and playerHRP.Parent) then
                return false
            end
            dist = (playerHRP.Position - target.Position).Magnitude
            local delta = (playerHRP.Position - lastPos).Magnitude
            if delta < 0.02 then
                stuckCount += 1
            else
                stuckCount = 0
            end
            lastPos = playerHRP.Position

            if stuckCount >= 10 and dist <= (stopDist + 2) then
                return true
            end
        until (dist <= stopDist) or (tick() - stepT0 > 0.6)

        if tick() - tStart > 15 then
            return false
        end
    end
    return false
end

-- Dropdown chọn threshold
FarmSec:Dropdown({
    Title    = "Min money per sec to buy",
    Options  = moneyOptions,
    Callback = function(val)
        config.BrainrotThresh = val
        saveConfig()
    end
})

local processedAnimals = setmetatable({}, { __mode = "k" })

local function findCandidate(threshVal)
    for _, animal in ipairs(workspace:GetChildren()) do
        repeat
            if processedAnimals[animal] then break end
            if not animal:IsA("Model") then break end

            local part = animal:FindFirstChild("Part")
            local info = part and part:FindFirstChild("Info")
            local overhead = info and info:FindFirstChild("AnimalOverhead")
            local genLabel = overhead and overhead:FindFirstChild("Generation")
            if not (genLabel and genLabel:IsA("TextLabel")) then break end

            local ok, val = pcall(function()
                return parseGen(genLabel.Text)
            end)
            if not ok or type(val) ~= "number" then break end
            if val < threshVal then break end

            local targetHRP = animal:FindFirstChild("HumanoidRootPart") or part
            if not targetHRP then break end

            return animal, targetHRP
        until true
    end
    return nil, nil
end

-- Toggle Auto buy Brainrot
FarmSec:Toggle({
    Title    = "Auto buy Brainrot",
    Default  = config.AutoBuyBrainrot,
    Callback = function(on)
        config.AutoBuyBrainrot = on
        saveConfig()

        if on then
            task.spawn(function()
                local player = Players.LocalPlayer
                processedAnimals = setmetatable({}, { __mode = "k" })

                local vim = VirtualInputManager

                while config.AutoBuyBrainrot do
                    local char = player.Character
                    local humanoid = char and char:FindFirstChildOfClass("Humanoid")
                    local playerHRP = char and char:FindFirstChild("HumanoidRootPart")
                    if not (humanoid and playerHRP) then
                        task.wait(0.5)
                        continue
                    end

                    local threshText = config.BrainrotThresh or moneyOptions[1]
                    local threshVal  = parseGen(tostring(threshText))

                    local animal, targetHRP = findCandidate(threshVal)

                    if animal and targetHRP and animal.Parent then
                        local arrived = followTarget(humanoid, playerHRP, targetHRP, 4)

                        if not (config.AutoBuyBrainrot and animal.Parent) then
                            task.wait(0.1)
                            continue
                        end

                        if arrived then
                            for i = 1, 2 do
                                if not (config.AutoBuyBrainrot and animal.Parent) then break end
                                local t0 = tick()
                                while (tick() - t0 < 0.5) and config.AutoBuyBrainrot and animal.Parent do
                                    vim:SendKeyEvent(true, Enum.KeyCode.E, false, game)
                                    pcall(function() pushOther(playerHRP) end)
                                    task.wait()
                                end
                                vim:SendKeyEvent(false, Enum.KeyCode.E, false, game)
                                task.wait(0.05)
                            end

                            processedAnimals[animal] = true
                        else
                            processedAnimals[animal] = true
                        end

                        task.wait(0.1)
                    else
                        task.wait(0.5)
                    end
                end
            end)
        end
    end
})

-- Anti AFK (giữ logic) + disconnect khi tắt
local antiAFKConn
FarmSec:Toggle({
    Title    = "Anti AFK",
    Default  = config.AutoPreventAFK,
    Callback = function(on)
        config.AutoPreventAFK = on
        saveConfig()

        if on then
            local Players       = game:GetService("Players")
            local vu            = game:GetService("VirtualUser")
            local localPlayer   = Players.LocalPlayer

            antiAFKConn = localPlayer.Idled:Connect(function()
                vu:Button2Down(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
                task.wait(1)
                vu:Button2Up(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
            end)

            task.spawn(function()
                while config.AutoPreventAFK do
                    vu:Button2Down(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
                    task.wait(1)
                    vu:Button2Up(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
                    task.wait(15 * 60)
                end
            end)
        else
            if antiAFKConn then antiAFKConn:Disconnect(); antiAFKConn = nil end
        end
    end
})

-- 3) AUTO LOCK BASE
config.Lockbase = config.Lockbase or false
FarmSec:Toggle({
    Title    = "Auto Lock Base",
    Default  = config.Lockbase,
    Callback = function(on)
        config.Lockbase = on; saveConfig()

        clearMethod("Lockbase")
        clearMethod("LockLockBV")
        isLocking = false

        if on then
            connections["Lockbase"] = RunService.Heartbeat:Connect(function()
                if not config.Lockbase or isLocking then return end

                local baseModel = getMyBase()
                if not baseModel then return end
                local plotBlock = baseModel:FindFirstChild("Purchases") and baseModel.Purchases:FindFirstChild("PlotBlock")
                local remLabel   = plotBlock and plotBlock.Main and plotBlock.Main.BillboardGui and plotBlock.Main.BillboardGui.RemainingTime
                local hitbox     = plotBlock and plotBlock:FindFirstChild("Hitbox")
                if not(remLabel and hitbox) then return end

                local num = tonumber(remLabel.Text:match("%d+")) or math.huge
                if num > 5 then return end

                isLocking = true
                task.spawn(function()
                    task.wait(0.5); respawnPlayer()
                    task.wait(3.6)
                    local char2 = Players.LocalPlayer.Character
                    local hrp2  = char2 and char2:FindFirstChild("HumanoidRootPart")
                    local hum2  = char2 and char2:FindFirstChildOfClass("Humanoid")
                    if not (hrp2 and hum2) then
                        isLocking = false
                        return
                    end

                    hum2:MoveTo(hitbox.Position)
                    hum2.MoveToFinished:Wait()

                    while true do
                        local n = tonumber(remLabel.Text:match("%d+")) or math.huge
                        if n > 5 then break end

                        local center = hitbox.Position
                        local toBox  = center - hrp2.Position
                        local horiz  = Vector3.new(toBox.X,0,toBox.Z)
                        local dir    = horiz.Unit

                        hum2:MoveTo(center - dir * 1.5)
                        hum2.MoveToFinished:Wait()

                        hum2:MoveTo(center + dir * 1.5)
                        hum2.MoveToFinished:Wait()
                    end

                    respawnPlayer()

                    if config.AutoBuyBrainrot then
                        clearMethod("AutoBuyBV")
                    end

                    isLocking = false
                end)
            end)
        end
    end
})

-- ============================
-- 3) AUTO COLLECT
-- ============================
isCollecting = isCollecting or false
local shouldRestartAutoCollect = false

config.CollectDelay = config.CollectDelay or 3

FarmSec:Toggle({
    Title    = "Auto Collect",
    Default  = config.AutoCollect,
    Callback = function(on)
        config.AutoCollect = on
        saveConfig()
        if not on then return end

        task.spawn(function()
            while config.AutoCollect do
                isCollecting = true
                shouldRestartAutoCollect = false

                while isLocking and config.AutoCollect do
                    shouldRestartAutoCollect = true
                    task.wait(1)
                end

                if shouldRestartAutoCollect then
                    continue
                end

                respawnPlayer()

                task.wait(3.6)
                local char = Players.LocalPlayer.Character or Players.LocalPlayer.CharacterAdded:Wait()
                local hrp = char:WaitForChild("HumanoidRootPart")

                local baseModel = getMyBase()
                if not baseModel then
                    task.wait(3)
                    continue
                end

                local podiums = baseModel:WaitForChild("AnimalPodiums")

                for i = 1, 10 do
                    if not config.AutoCollect then break end

                    while isLocking do
                        shouldRestartAutoCollect = true
                        task.wait(1)
                    end
                    if shouldRestartAutoCollect then break end

                    local model = podiums:FindFirstChild(tostring(i))
                    local claim = model and model:FindFirstChild("Claim")
                    if claim then
                        local bv = Instance.new("BodyVelocity", hrp)
                        bv.MaxForce = Vector3.new(1e5, 0, 1e5)
                        bv.P = 1e4

                        while config.AutoCollect and model and claim and claim:IsDescendantOf(game) do
                            if isLocking then
                                shouldRestartAutoCollect = true
                                break
                            end

                            local part = claim:IsA("BasePart") and claim or claim:FindFirstChildWhichIsA("BasePart")
                            if part then
                                local toTarget = part.Position - hrp.Position
                                local horiz = Vector3.new(toTarget.X, 0, toTarget.Z)
                                if horiz.Magnitude > 2 then
                                    bv.Velocity = horiz.Unit * 30
                                else
                                    bv.Velocity = Vector3.zero
                                    break
                                end
                            end

                            RunService.Heartbeat:Wait()
                        end

                        bv:Destroy()
                        task.wait(0.05)
                    else
                        print("[AutoCollect] Không tìm thấy claim ở podium: " .. i)
                    end
                end

                if shouldRestartAutoCollect then
                    continue
                end

                task.wait(1)

                if config.AutoBuyBrainrot then
                    clearMethod("AutoBuyBV")
                end

                isCollecting = false

                local delayMin = tonumber(config.CollectDelay) or 3
                for s = 1, delayMin * 60 do
                    if not config.AutoCollect then break end
                    task.wait(1)
                end
            end
            isCollecting = false
        end)
    end
})

-- Input (textbox) cho Collect Delay
FarmSec:Input({
    Title       = "Collect Delay (minutes)",
    Placeholder = "e.g. 3",
    Default     = tostring(config.CollectDelay or ""),
    Callback    = function(val)
        local num = tonumber(val)
        if num then config.CollectDelay = num; saveConfig() end
    end
})
-- ================= Remaining helpers/logic (MacLib + auto-apply theo JSON) =================

local rs        = game:GetService("ReplicatedStorage")
local packages  = rs:WaitForChild("Packages")
local netFolder = packages:WaitForChild("Net")

local Players     = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local LP          = Players.LocalPlayer

-- fallback trim nếu chưa có
trim = trim or function(s) return (s and s:match('^%s*(.-)%s*$')) or "" end

local bestSpawnPart

function respawnPlayer()
    local char = LP.Character
    if not char then return end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.Health = 0
    else
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if hrp then hrp:BreakJoints() end
    end
end

--================================================================
-- BẢO ĐẢM LƯU/ĐỌC CONFIG GIỐNG AUTO BUY ITEM + GHI HỢP NHẤT
--================================================================
CONFIG_FOLDER = CONFIG_FOLDER or "Chilli Hub Brainot"
CONFIG_FILE   = CONFIG_FILE   or ((LP and LP.Name) and (LP.Name .. ".json") or "Player.json")
CONFIG_PATH   = CONFIG_PATH   or (CONFIG_FOLDER .. "/" .. CONFIG_FILE)

_G.config = _G.config or {}
config = _G.config -- dùng chung RAM, KHÔNG local

local function READ_DISK()
    local t = {}
    pcall(function()
        if isfile and readfile and isfile(CONFIG_PATH) then
            local raw = readfile(CONFIG_PATH)
            if raw and #raw > 0 then
                local ok, data = pcall(HttpService.JSONDecode, HttpService, raw)
                if ok and type(data) == "table" then t = data end
            end
        end
    end)
    return t
end

local function WRITE_KV(kv)
    pcall(function()
        if makefolder and isfolder and not isfolder(CONFIG_FOLDER) then
            makefolder(CONFIG_FOLDER)
        end
        local disk = READ_DISK()
        for k,v in pairs(kv) do
            disk[k]   = v
            config[k] = v -- sync RAM
        end
        if writefile then
            writefile(CONFIG_PATH, HttpService:JSONEncode(disk))
        end
    end)
    if saveConfig then pcall(saveConfig) end
end

-- HỢP NHẤT FILE → RAM NGAY LÚC LOAD
local __disk_boot = READ_DISK()
for k,v in pairs(__disk_boot) do
    config[k] = v
end

--================================================================
-- Highest Value Brainrot ESP
--================================================================
priceLabels = priceLabels or {}
function formatPrice(value)
    if value >= 1e9 then
        return tostring(math.floor(value / 1e9)) .. "B"
    elseif value >= 1e6 then
        return tostring(math.floor(value / 1e6)) .. "M"
    elseif value >= 1e3 then
        return tostring(math.floor(value / 1e3)) .. "K"
    else
        return tostring(math.floor(value))
    end
end

local function addPriceLabel(obj)
    if obj:IsA("TextLabel") and obj.Name == "Price" then
        table.insert(priceLabels, obj)
    end
end
local function removePriceLabel(obj)
    for i, v in ipairs(priceLabels) do
        if v == obj then table.remove(priceLabels, i); break end
    end
end

for _, obj in ipairs(workspace:GetDescendants()) do addPriceLabel(obj) end
workspace.DescendantAdded:Connect(addPriceLabel)
workspace.DescendantRemoving:Connect(removePriceLabel)

local highestESP, highestBillboard
local function clearHighestESP()
    if highestESP then highestESP:Destroy(); highestESP = nil end
    if highestBillboard then highestBillboard:Destroy(); highestBillboard = nil end
end

function getStealPromptFromSpawn(spawn)
    local pa = spawn and spawn:FindFirstChild("PromptAttachment")
    if not pa then return nil end
    for _, d in ipairs(pa:GetDescendants()) do
        if d:IsA("ProximityPrompt") and tostring(d.ActionText) == "Steal" then
            return d
        end
    end
    return nil
end

function deepFindTextLabel(container, name)
    if not container then return nil end
    local fallback
    for _, d in ipairs(container:GetDescendants()) do
        if d:IsA("TextLabel") and d.Name == name then
            local p, under = d.Parent, false
            while p do
                if p.Name == "AnimalOverhead" then under = true; break end
                p = p.Parent
            end
            if under then return d end
            if not fallback then fallback = d end
        end
    end
    return fallback
end

local function deepFindFirst(container, name)
    if not container then return nil end
    for _, d in ipairs(container:GetDescendants()) do
        if d.Name == name then return d end
    end
    return nil
end

local function findPlotFromSpawn(spawn)
    local n = spawn
    while n and n ~= workspace do
        if n.Parent == workspace.Plots then
            return n
        end
        n = n.Parent
    end
    return nil
end

local function findOverheadFromSpawnOrObject(spawn)
    local overhead, objText, specialModel

    local att = spawn and spawn:FindFirstChild("Attachment")
    if att then
        local oh = att:FindFirstChild("AnimalOverhead")
        if oh then overhead = oh end
    end

    local prompt = getStealPromptFromSpawn(spawn)
    if prompt then
        objText = trim(tostring(prompt.ObjectText or ""))
        if objText ~= "" then
            local plot = findPlotFromSpawn(spawn)
            local model = (plot and plot:FindFirstChild(objText)) or (plot and deepFindFirst(plot, objText))
            if (not model) then model = workspace:FindFirstChild(objText) end

            if model and model:IsA("Model") then
                local oh2
                for _, d in ipairs(model:GetDescendants()) do
                    if d.Name == "AnimalOverhead" then oh2 = d; break end
                end
                if oh2 then
                    overhead     = oh2
                    specialModel = model
                end
            end
        end
    end

    return overhead, objText, specialModel
end

--==== ESP loop controls
_espLoopActive = _espLoopActive or false

function startESP()
    if _espLoopActive then return end
    _espLoopActive = true
    task.spawn(function()
        while config.ESPHighestNPC_All do
            local bestPart, bestGenText
            local ok, r1, r2 = pcall(function()
                return findHighestValueSpawnAll() -- giữ nguyên hàm đã có từ phần trước
            end)
            if ok then bestPart, bestGenText = r1, r2 else warn("[ESP] findHighestValueSpawnAll error:", r1) end

            clearHighestESP()

            if bestPart and bestPart.Parent then
                local spawn = bestPart
                local overhead, objText, targetModel = findOverheadFromSpawnOrObject(spawn)
                targetModel = targetModel or bestPart.Parent

                if targetModel then
                    local hl = Instance.new("Highlight", targetModel)
                    hl.Name                = "ESP_HighestNPC_All"
                    hl.Adornee             = targetModel
                    hl.FillColor           = Color3.fromRGB(50, 200, 255)
                    hl.FillTransparency    = 0.2
                    hl.OutlineColor        = Color3.fromRGB(255, 255, 255)
                    hl.OutlineTransparency = 0
                    hl.DepthMode           = Enum.HighlightDepthMode.AlwaysOnTop
                    highestESP = hl
                end

                local billboard = Instance.new("BillboardGui", targetModel or bestPart)
                billboard.Name                    = "GenerationTag_All"
                billboard.Adornee                 = (targetModel and targetModel.PrimaryPart) or bestPart
                billboard.AlwaysOnTop             = true
                billboard.ExtentsOffsetWorldSpace = Vector3.new(0, 3, 0)
                billboard.Size                    = UDim2.new(0, 120, 0, 60)
                billboard.StudsOffsetWorldSpace   = Vector3.new(0, 3, 0)
                highestBillboard = billboard

                local nameText = ""
                local dispLbl  = overhead and overhead:FindFirstChild("DisplayName")
                if dispLbl and dispLbl:IsA("TextLabel") then
                    nameText = dispLbl.Text:match("([^%(]+)") or dispLbl.Text
                else
                    nameText = objText or ((targetModel and targetModel.Name) or "")
                end

                local nameLbl = Instance.new("TextLabel", billboard)
                nameLbl.Size                   = UDim2.new(1.5, 0, 0.7, 0)
                nameLbl.AnchorPoint            = Vector2.new(0.5, 0.5)
                nameLbl.Position               = UDim2.new(0.5, 0, 0.5, 0)
                nameLbl.BackgroundTransparency = 1
                nameLbl.TextScaled             = true
                nameLbl.Font                   = Enum.Font.SourceSansBold
                nameLbl.TextColor3             = Color3.fromRGB(255, 255, 0)
                nameLbl.TextStrokeColor3       = Color3.fromRGB(0, 0, 0)
                nameLbl.TextStrokeTransparency = 0
                nameLbl.Text                   = nameText

                local mutSrc = overhead and overhead:FindFirstChild("Mutation")
                if not mutSrc and targetModel then
                    mutSrc = deepFindTextLabel(targetModel, "Mutation")
                end
                if mutSrc and mutSrc:IsA("TextLabel") and mutSrc.Visible and (mutSrc.Text and mutSrc.Text ~= "{Mutation_Name}") then
                    local mLbl = Instance.new("TextLabel", billboard)
                    mLbl.Size                   = UDim2.new(1.3, 0, 0.55, 0)
                    mLbl.AnchorPoint            = Vector2.new(0.5, 0.5)
                    mLbl.Position               = UDim2.new(0.5, 0, 0.05, 0)
                    mLbl.BackgroundTransparency = 1
                    mLbl.TextScaled             = true
                    mLbl.Font                   = Enum.Font.SourceSansBold
                    mLbl.TextColor3             = Color3.fromRGB(0, 191, 255)
                    mLbl.TextStrokeColor3       = Color3.fromRGB(0, 0, 0)
                    mLbl.TextStrokeTransparency = 0
                    mLbl.Text                   = mutSrc.Text
                end

                local genDisplay = Instance.new("TextLabel", billboard)
                genDisplay.Size                   = UDim2.new(1, 0, 0.5, 0)
                genDisplay.AnchorPoint            = Vector2.new(0.5, 0.5)
                genDisplay.Position               = UDim2.new(0.5, 0, 0.9, 0)
                genDisplay.BackgroundTransparency = 1
                genDisplay.TextScaled             = true
                genDisplay.Font                   = Enum.Font.SourceSansBold
                genDisplay.TextColor3             = Color3.fromRGB(0, 255, 0)
                genDisplay.TextStrokeColor3       = Color3.fromRGB(0, 0, 0)
                genDisplay.TextStrokeTransparency = 0
                genDisplay.Text                   = bestGenText or ""
            end

            task.wait(1)
        end
        clearHighestESP()
        _espLoopActive = false
    end)
end

function stopESP()
    clearHighestESP()
    _espLoopActive = false
end

--================================================================
-- TIMER ESP
--================================================================
timerESPList  = timerESPList  or {}

if not clearTimerESP then
    function clearTimerESP()
        for _, gui in ipairs(timerESPList) do
            if gui and gui.Parent then gui:Destroy() end
        end
        timerESPList = {}
    end
end

TimerESPState = TimerESPState or { enabled = false, loopRunning = false }

function TimerESP_setEnabled(on)
    on = (on == true)
    TimerESPState.enabled = on
    if not on then
        clearTimerESP()
        return
    end
    if TimerESPState.loopRunning then return end
    TimerESPState.loopRunning = true

    task.spawn(function()
        while TimerESPState.enabled do
            clearTimerESP()
            local plots = workspace:FindFirstChild("Plots")
            if plots then
                for _, plot in ipairs(plots:GetChildren()) do
                    local purchases = plot:FindFirstChild("Purchases")
                    local pb        = purchases and purchases:FindFirstChild("PlotBlock")
                    local main      = pb and pb:FindFirstChild("Main")
                    local bill      = main and main:FindFirstChild("BillboardGui")

                    if bill then
                        local rem = bill:FindFirstChild("RemainingTime")
                        if rem and rem:IsA("TextLabel") then
                            local espBill = Instance.new("BillboardGui")
                            espBill.Name        = "TimerESP"
                            espBill.AlwaysOnTop = true
                            espBill.Parent      = plot

                            local adornee = bill.Adornee
                            if not adornee then
                                adornee = plot.PrimaryPart or plot:FindFirstChildWhichIsA("BasePart", true)
                            end
                            espBill.Adornee = adornee
                            espBill.ExtentsOffsetWorldSpace = Vector3.new(0, 3, 0)

                            local isZero = (tostring(rem.Text) == "0s")
                            espBill.Size = isZero and UDim2.new(0, 120, 0, 50) or UDim2.new(0, 100, 0, 30)

                            local lbl = Instance.new("TextLabel")
                            lbl.Size                   = UDim2.new(1, 0, 1, 0)
                            lbl.AnchorPoint            = Vector2.new(0.5, 0.5)
                            lbl.Position               = UDim2.new(0.5, 0, 0.5, 0)
                            lbl.BackgroundTransparency = 1
                            lbl.TextScaled             = true
                            lbl.Font                   = Enum.Font.SourceSansBold
                            lbl.TextStrokeTransparency = 0
                            lbl.TextStrokeColor3       = Color3.fromRGB(0, 0, 0)
                            if isZero then
                                lbl.Text       = "UNLOCKED"
                                lbl.TextColor3 = Color3.fromRGB(0, 255, 0)
                            else
                                lbl.Text       = tostring(rem.Text)
                                lbl.TextColor3 = Color3.fromRGB(255, 255, 255)
                            end
                            lbl.Parent = espBill

                            table.insert(timerESPList, espBill)
                        end
                    end
                end
            end
            task.wait(1)
        end
        clearTimerESP()
        TimerESPState.loopRunning = false
    end)
end

--================================================================
-- PLAYER ESP
--================================================================
playerESPList     = playerESPList     or {}
playerESPConns    = playerESPConns    or {}
opaqueConnsByUser = opaqueConnsByUser or {}

local GREEN = Color3.fromRGB(0, 255, 200)

local function disconnectAll(conns)
    if not conns then return end
    for _, c in ipairs(conns) do
        if typeof(c) == "RBXScriptConnection" then
            pcall(function() c:Disconnect() end)
        end
    end
end

local function cleanupForUser(userId)
    if opaqueConnsByUser[userId] then
        disconnectAll(opaqueConnsByUser[userId])
        opaqueConnsByUser[userId] = nil
    end
    local bucket = playerESPList[userId]
    if bucket then
        if bucket.conns then disconnectAll(bucket.conns) end
        if bucket.objs then
            for _, o in ipairs(bucket.objs) do
                pcall(function() if o and o.Parent then o:Destroy() end end)
            end
        end
        playerESPList[userId] = nil
    end
end

local function clearPlayerESP()
    for uid,_ in pairs(opaqueConnsByUser) do cleanupForUser(uid) end
    for uid,_ in pairs(playerESPList)     do cleanupForUser(uid) end
    disconnectAll(playerESPConns)
    table.clear(playerESPConns)
end

local function ensureUserBucket(userId)
    playerESPList[userId]     = playerESPList[userId]     or { objs = {}, conns = {} }
    opaqueConnsByUser[userId] = opaqueConnsByUser[userId] or {}
    return playerESPList[userId]
end
local function addConnForUser(userId, conn)
    local b = ensureUserBucket(userId)
    table.insert(b.conns, conn)
end
local function addObjForUser(userId, obj)
    local b = ensureUserBucket(userId)
    table.insert(b.objs, obj)
end

local function attachOpaqueWatchersForPart(userId, part)
    if not part or part.Name == "HumanoidRootPart" then return end
    local function applyOpaque()
        if part and part.Parent then
            if part.Transparency ~= 0 then part.Transparency = 0 end
            if part.LocalTransparencyModifier ~= 0 then part.LocalTransparencyModifier = 0 end
        end
    end
    applyOpaque()
    local c1 = part:GetPropertyChangedSignal("Transparency"):Connect(applyOpaque)
    local c2 = part:GetPropertyChangedSignal("LocalTransparencyModifier"):Connect(applyOpaque)
    table.insert(opaqueConnsByUser[userId], c1)
    table.insert(opaqueConnsByUser[userId], c2)
end

local function attachOpaqueWatchersForCharacter(userId, char)
    for _, d in ipairs(char:GetDescendants()) do
        if d:IsA("BasePart") and d.Name ~= "HumanoidRootPart" then
            attachOpaqueWatchersForPart(userId, d)
        end
    end
    local cD = char.DescendantAdded:Connect(function(inst)
        if inst:IsA("BasePart") and inst.Name ~= "HumanoidRootPart" then
            attachOpaqueWatchersForPart(userId, inst)
        end
    end)
    table.insert(opaqueConnsByUser[userId], cD)
end

local function createCharacterHighlight(char)
    local hl = Instance.new("Highlight")
    hl.Name                = "PlayerESP_Char"
    hl.Adornee             = char
    hl.FillColor           = GREEN
    hl.FillTransparency    = 0.22
    hl.OutlineColor        = GREEN
    hl.OutlineTransparency = 0.08
    hl.DepthMode           = Enum.HighlightDepthMode.AlwaysOnTop
    hl.Parent              = char
    return hl
end

local function createDisplayNameBillboard(root, char, displayName)
    local extents = char:GetExtentsSize()
    local bill = Instance.new("BillboardGui")
    bill.Name                  = "PlayerESP_DisplayName"
    bill.Adornee               = root
    bill.AlwaysOnTop           = true
    bill.MaxDistance           = 600
    bill.StudsOffsetWorldSpace = Vector3.new(0, extents.Y/2 + 0.9, 0)
    bill.Size                  = UDim2.new(0, 96, 0, 18)

    local bg = Instance.new("Frame")
    bg.Name                    = "BG"
    bg.Parent                  = bill
    bg.AnchorPoint             = Vector2.new(0.5, 0.5)
    bg.Position                = UDim2.fromScale(0.5, 0.5)
    bg.Size                    = UDim2.new(1, 0, 1, 0)
    bg.BackgroundColor3        = Color3.fromRGB(0, 0, 0)
    bg.BackgroundTransparency  = 0.45
    Instance.new("UICorner", bg).CornerRadius = UDim.new(0, 6)
    local pad = Instance.new("UIPadding", bg)
    pad.PaddingLeft, pad.PaddingRight = UDim.new(0, 6), UDim.new(0, 6)
    pad.PaddingTop,  pad.PaddingBottom= UDim.new(0, 1), UDim.new(0, 1)

    local lbl = Instance.new("TextLabel")
    lbl.Name                   = "Label"
    lbl.Parent                 = bg
    lbl.BackgroundTransparency = 1
    lbl.Size                   = UDim2.new(1, 0, 1, 0)
    lbl.Font                   = Enum.Font.GothamSemibold
    lbl.TextSize               = 13
    lbl.Text                   = tostring(displayName or "")
    lbl.TextColor3             = Color3.fromRGB(255, 255, 255)
    lbl.TextStrokeTransparency = 0.12
    lbl.TextStrokeColor3       = Color3.fromRGB(0, 0, 0)
    lbl.TextXAlignment         = Enum.TextXAlignment.Center
    lbl.TextYAlignment         = Enum.TextYAlignment.Center

    task.defer(function()
        if not (bill and lbl) then return end
        local tb = lbl.TextBounds
        bill.Size = UDim2.new(0, math.clamp(tb.X + 12, 64, 180), 0, math.clamp(tb.Y + 4, 16, 24))
    end)

    return bill
end

local function waitForCharacterReady(pl, timeout)
    local t0 = os.clock()
    local char = pl.Character
    if not char then
        local ok, got = pcall(function() return pl.CharacterAdded:Wait() end)
        if ok then char = got end
    end
    if not char then return nil end

    timeout = timeout or 8
    while os.clock() - t0 < timeout do
        if not char.Parent then return nil end
        if char:FindFirstChild("HumanoidRootPart") then
            return char
        end
        task.wait(0.1)
    end
    return char
end

local function mountESPForCharacter(pl, char)
    if pl == LP then return end
    local userId = pl.UserId
    cleanupForUser(userId)
    ensureUserBucket(userId)

    local hl = createCharacterHighlight(char)
    addObjForUser(userId, hl)

    local root = char:FindFirstChild("HumanoidRootPart") or char.PrimaryPart
    if root then
        local bill = createDisplayNameBillboard(root, char, pl.DisplayName)
        bill.Parent = root
        addObjForUser(userId, bill)
    end

    attachOpaqueWatchersForCharacter(userId, char)

    local dnConn = pl:GetPropertyChangedSignal("DisplayName"):Connect(function()
        local bucket = playerESPList[userId]
        if not (bucket and bucket.objs) then return end
        for _, o in ipairs(bucket.objs) do
            if o:IsA("BillboardGui") then
                local bg  = o:FindFirstChild("BG")
                local lbl = bg and bg:FindFirstChild("Label")
                if lbl and lbl:IsA("TextLabel") then
                    lbl.Text = pl.DisplayName or ""
                    task.defer(function()
                        local tb = lbl.TextBounds
                        o.Size = UDim2.new(0, math.clamp(tb.X + 12, 64, 180), 0, math.clamp(tb.Y + 4, 16, 24))
                    end)
                end
            end
        end
    end)
    addConnForUser(userId, dnConn)
end

local function attachAllWatchersForPlayer(pl)
    if pl == LP then return end

    local cA = pl.CharacterAdded:Connect(function(_char)
        if not config.PlayerBox then return end
        task.defer(function()
            if not config.PlayerBox then return end
            local okChar = waitForCharacterReady(pl, 8)
            if config.PlayerBox and okChar and pl.Character == okChar then
                mountESPForCharacter(pl, okChar)
            end
        end)
    end)
    table.insert(playerESPConns, cA)

    local cR = pl.CharacterRemoving:Connect(function()
        cleanupForUser(pl.UserId)
    end)
    table.insert(playerESPConns, cR)

    task.spawn(function()
        if not config.PlayerBox then return end
        local char = waitForCharacterReady(pl, 8)
        if config.PlayerBox and char and pl.Character == char then
            mountESPForCharacter(pl, char)
        end
    end)
end

local function startPlayerESP()
    clearPlayerESP()
    local added = Players.PlayerAdded:Connect(function(pl)
        if not config.PlayerBox then return end
        attachAllWatchersForPlayer(pl)
    end)
    table.insert(playerESPConns, added)

    local removing = Players.PlayerRemoving:Connect(function(pl)
        cleanupForUser(pl.UserId)
    end)
    table.insert(playerESPConns, removing)

    for _, pl in ipairs(Players:GetPlayers()) do
        attachAllWatchersForPlayer(pl)
    end
end

local function stopPlayerESP()
    clearPlayerESP()
end

--================================================================
-- MAC LIB UI (ESP) — CHỈ 01 SECTION + 3 TOGGLE
--================================================================
local EspSec = HelpDTKTab:Section({ Title = "ESP", Opened = true })

EspSec:Toggle({
    Title    = "Highest Value Brainrot ESP",
    Default  = (config.ESPHighestNPC_All == true),
    Callback = function(on)
        local want = (on == true)
        config.ESPHighestNPC_All = want
        WRITE_KV({ ESPHighestNPC_All = want })
        if want then startESP() else stopESP() end
    end
})

EspSec:Toggle({
    Title    = "Timer ESP",
    Default  = (config.TimerESP == true),
    Callback = function(on)
        local want = (on == true)
        config.TimerESP = want
        WRITE_KV({ TimerESP = want })
        TimerESP_setEnabled(want)
    end
})

EspSec:Toggle({
    Title    = "Player ESP",
    Default  = (config.PlayerBox == true),
    Callback = function(on)
        local want = (on == true)
        config.PlayerBox = want
        WRITE_KV({ PlayerBox = want })
        if want then startPlayerESP() else stopPlayerESP() end
    end
})

--================================================================
-- AUTO-APPLY SAU KHI LOAD THEO JSON (không phụ thuộc UI callback)
--================================================================
task.defer(function()
    if config.ESPHighestNPC_All == true then startESP() else stopESP() end
    if config.TimerESP          == true then TimerESP_setEnabled(true) else TimerESP_setEnabled(false) end
    if config.PlayerBox         == true then startPlayerESP() else stopPlayerESP() end
end)
do
    -- LocalScript @ StarterPlayerScripts  (CoreGui; MacLib toggle; SAVE/LOAD JSON chắc cú + AUTO-APPLY)
    --========================================================
    -- SERVICES & BIẾN CHUNG
    --========================================================
    local cloneref = cloneref or function(o) return o end
    local Players            = cloneref(game:GetService("Players"))
    local ReplicatedStorage  = cloneref(game:GetService("ReplicatedStorage"))
    local RunService         = cloneref(game:GetService("RunService"))
    local UserInputService   = cloneref(game:GetService("UserInputService"))
    local TweenService       = cloneref(game:GetService("TweenService"))
    local HttpService        = cloneref(game:GetService("HttpService"))

    local player = Players.LocalPlayer
    if not player then return end

    if not LPH_OBFUSCATED then
        LPH_NO_VIRTUALIZE = function(...) return(...) end
    end

    --========================================================
    -- CONFIG: ĐỌC FILE TRƯỚC, SAU ĐÓ MỚI GÁN DEFAULT + AUTO MERGE VÀO _G.config
    --========================================================
    local function SB_readDisk()
        local t = {}
        pcall(function()
            if CONFIG_PATH and isfile and readfile and isfile(CONFIG_PATH) then
                local raw = readfile(CONFIG_PATH)
                if raw and #raw > 0 then
                    local ok, data = pcall(HttpService.JSONDecode, HttpService, raw)
                    if ok and type(data)=="table" then t = data end
                end
            end
        end)
        return t
    end

    local function SB_writeDisk(keyvals)
        -- Ghi trực tiếp JSON (merge), sau đó đồng bộ _G.config
        pcall(function()
            if not (CONFIG_FOLDER and CONFIG_PATH) then return end
            if makefolder and isfolder and not isfolder(CONFIG_FOLDER) then
                makefolder(CONFIG_FOLDER)
            end
            local disk = SB_readDisk()
            for k,v in pairs(keyvals) do disk[k] = v end
            if _G and _G.config then
                for k,v in pairs(keyvals) do _G.config[k] = v end
            end
            if writefile then
                writefile(CONFIG_PATH, HttpService:JSONEncode(disk))
            end
        end)
        if saveConfig then pcall(saveConfig) end
    end

    -- dùng chung bảng config (đã có ở đầu script chính)
    local config = (_G and _G.config) or (_G) or {}
    do
        -- HỢP NHẤT FILE → RAM NGAY KHI LOAD (đảm bảo auto-apply)
        local __disk_all = SB_readDisk()
        for k,v in pairs(__disk_all) do config[k] = v end
    end

    --========================================================
    -- CẤU HÌNH & DEFAULT (sau khi đã có __disk)
    --========================================================
    local SB_SPAM_CONFIG_DEFAULT = { REEQUIP_DELAY = 0 }

    local function SB_mergeSpamConfig(base, overrides)
        local out = {}
        for k, v in pairs(base) do out[k] = v end
        if type(overrides) == "table" then
            for k, v in pairs(overrides) do
                if base[k] ~= nil and (type(v) == type(base[k])) then
                    out[k] = v
                end
            end
        end
        return out
    end

    -- SpeedBoost core (đọc từ file trước, sau đó set default nếu nil)
    if config.SpeedBoost == nil then
        config.SpeedBoost = false
    end
    if config.SpeedBoost_Speed == nil then
        config.SpeedBoost_Speed = 130
    end
    config.SpeedBoost_Speed = math.clamp(tonumber(config.SpeedBoost_Speed) or 130, 0, 180)
    if config.SpeedBoost_Key == nil then
        config.SpeedBoost_Key = "Q"
    end

    -- Trạng thái hiển thị UI & thu gọn UI
    if config.SpeedBoostUIEnabled == nil then
        config.SpeedBoostUIEnabled = true
    end
    if config.SpeedBoostUICollapsed == nil then
        config.SpeedBoostUICollapsed = false
    end

    config.SB_Spam = SB_mergeSpamConfig(SB_SPAM_CONFIG_DEFAULT, config.SB_Spam)
    local SB_SPAM = config.SB_Spam

    -- Helper: GHI & LƯU SpeedBoostUIEnabled trực tiếp ra JSON
    local function SB_forceSaveUIEnabled(val)
        local v = (val == true)
        config.SpeedBoostUIEnabled = v
        SB_writeDisk({ SpeedBoostUIEnabled = v })
    end

    --========================================================
    -- TIỆN ÍCH GRAPPLE / SHOP
    --========================================================
    local function SB_isGrappleTool(tool)
        if not tool or not tool:IsA("Tool") or not tool.Name then return false end
        local n = string.lower(tool.Name)
        return n:find("grapple") ~= nil or tool.Name == "Grapple Hook"
    end

    local function SB_findGrappleInInventory()
        local bp = player:FindFirstChild("Backpack")
        if bp then
            for _, it in ipairs(bp:GetChildren()) do
                if SB_isGrappleTool(it) then return true end
            end
        end
        local char = player.Character
        if char then
            for _, it in ipairs(char:GetChildren()) do
                if SB_isGrappleTool(it) then return true end
            end
        end
        return false
    end

    local function SB_tryBuyGrappleOnce()
        local ok, rf = pcall(function()
            return ReplicatedStorage:WaitForChild("Packages"):WaitForChild("Net"):WaitForChild("RF/CoinsShopService/RequestBuy")
        end)
        if not ok or not rf then return false, "RequestBuy RF not found" end
        local succ, res = pcall(function() return rf:InvokeServer("Grapple Hook") end)
        return succ, res
    end

    local function SB_ensureGrappleAvailable(opts)
        opts = opts or {}
        local attempts = opts.attempts or 2
        local waitBetween = opts.waitBetween or 0.6
        if SB_findGrappleInInventory() then return true end
        for _ = 1, attempts do
            local bought = SB_tryBuyGrappleOnce()
            if bought then
                local waited, timeout = 0, 3
                while waited < timeout do
                    if SB_findGrappleInInventory() then return true end
                    task.wait(0.25); waited += 0.25
                end
            end
            task.wait(waitBetween)
        end
        return SB_findGrappleInInventory()
    end

    --========================================================
    -- BOOST CONTROLLER (di chuyển)
    --========================================================
    local function SB_makeBoostController(params)
        local self = {}
        self.conn = nil
        self.died = nil
        local function alphaFrom(resp, dt) return 1 - math.exp(-resp * dt) end
        function self:stop()
            if self.conn then self.conn:Disconnect(); self.conn = nil end
            if self.died then self.died:Disconnect(); self.died = nil end
        end
        function self:start(hum, hrp)
            self:stop()
            local DECAY_GROUND, DECAY_AIR, SPEED_EPS = 18, 4, 0.35
            local acc, lastOnGround = 0, true
            local airStartTime, carryDir, tookoffHasInput, lastExitHorizSpeed = 0, Vector3.zero, false, 0
            self.conn = RunService.Heartbeat:Connect(function(dt)
                acc += dt
                local step = params.INTERVAL
                if acc < step then return end
                while acc >= step do
                    acc -= step
                    if hum.Health <= 0 then break end
                    if not hrp or not hrp.Parent then break end
                    local v = hrp.AssemblyLinearVelocity
                    local horiz = Vector3.new(v.X, 0, v.Z)
                    local onGround = hum.FloorMaterial ~= Enum.Material.Air
                    local now = os.clock()
                    if lastOnGround and not onGround then
                        airStartTime = now
                        lastExitHorizSpeed = horiz.Magnitude
                        local md = hum.MoveDirection
                        tookoffHasInput = md.Magnitude > 0.05
                        carryDir = tookoffHasInput and md.Unit or Vector3.zero
                    end
                    lastOnGround = onGround
                    local md = hum.MoveDirection
                    local haveInput = md.Magnitude > 0.01
                    local dir = Vector3.zero
                    if haveInput then
                        dir = md.Unit
                    elseif not onGround then
                        local stickT = params.AIR_STICK_TIME
                        local stickOnlyIf = (params.STICK_ONLY_IF_INPUT ~= false)
                        if (now - airStartTime) <= stickT then
                            if (stickOnlyIf and tookoffHasInput and carryDir.Magnitude > 0)
                            or ((not stickOnlyIf) and carryDir.Magnitude > 0) then
                                dir = carryDir
                            end
                        end
                    end
                    local inNoInputGrace = (not onGround) and (not tookoffHasInput) and (not haveInput)
                            and ((now - airStartTime) <= params.AIR_NO_INPUT_GRACE)

                    if dir.Magnitude > 0 and (not inNoInputGrace) then
                        local baseWS = hum.WalkSpeed
                        local targetSpeed = math.clamp(baseWS + (params.EXTRA_SPEED or 0), 0, (params.MAX_SPEED or 180))
                        if (params.AIR_CONTROL ~= false) and (not onGround) and (params.PRESERVE_MOMENTUM ~= false) then
                            targetSpeed = math.clamp(math.max(targetSpeed, lastExitHorizSpeed), 0, (params.MAX_SPEED or 180))
                        end
                        local targetHoriz = dir * targetSpeed
                        local resp = (onGround and (params.RESP_GROUND or 14) or (params.RESP_AIR or 10))
                        local a = alphaFrom(resp, step)
                        local newHoriz = horiz:Lerp(targetHoriz, a)
                        if onGround and newHoriz.Magnitude < SPEED_EPS then newHoriz = Vector3.zero end
                        hrp.AssemblyLinearVelocity = Vector3.new(newHoriz.X, v.Y, newHoriz.Z)
                    else
                        local decay = onGround and DECAY_GROUND or DECAY_AIR
                        if decay > 0 then
                            local factor = math.exp(-decay * step)
                            local newHoriz = horiz * factor
                            if onGround and newHoriz.Magnitude < SPEED_EPS then newHoriz = Vector3.zero end
                            hrp.AssemblyLinearVelocity = Vector3.new(newHoriz.X, v.Y, newHoriz.Z)
                        end
                    end
                end
            end)
            self.died = hum.Died:Connect(function() self:stop() end)
        end
        return self
    end

    --========================================================
    -- FIRE + EQUIP GRAPPLE
    --========================================================
    local function SB_FireGrappleNear()
        ReplicatedStorage.Packages.Net["RE/UseItem"]:FireServer(1.983)
        local char = player.Character or player.CharacterAdded:Wait()
        if not char or not char.Parent then return end
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if not humanoid then return end
        ReplicatedStorage.Packages.Net["RE/UseItem"]:FireServer(1.983)
        local tool = (player.Backpack and player.Backpack:FindFirstChild("Grapple Hook")) or char:FindFirstChild("Grapple Hook")
        if not tool then return end
        ReplicatedStorage.Packages.Net["RE/UseItem"]:FireServer(1.983)
        if tool.Parent == player.Backpack then
            pcall(function() humanoid:EquipTool(tool) end)
        end
        if char:FindFirstChild("Grapple Hook") then
            ReplicatedStorage.Packages.Net["RE/UseItem"]:FireServer(1.983)
        end
    end

    --========================================================
    -- (REEQUIP) HOOK Unequipped và equip lại sau REEQUIP_DELAY
    --========================================================
    local SB_toolEquippedConns, SB_toolUnequippedConns, SB_bpAddedConn = {}, {}, nil
    local function SB_clearToolConns()
        for _,c in pairs(SB_toolEquippedConns)  do if c then c:Disconnect() end end
        for _,c in pairs(SB_toolUnequippedConns) do if c then c:Disconnect() end end
        SB_toolEquippedConns, SB_toolUnequippedConns = {}, {}
        if SB_bpAddedConn then SB_bpAddedConn:Disconnect(); SB_bpAddedConn=nil end
    end

    local function SB_hookGrappleTool(tool)
        if not tool or not SB_isGrappleTool(tool) then return end
        if not SB_toolEquippedConns[tool] then
            SB_toolEquippedConns[tool] = tool.Equipped:Connect(function()
                ReplicatedStorage.Packages.Net["RE/UseItem"]:FireServer(1.983)
            end)
        end
        if not SB_toolUnequippedConns[tool] then
            SB_toolUnequippedConns[tool] = tool.Unequipped:Connect(function()
                if not config.SpeedBoost then return end
                local delaySec = tonumber(SB_SPAM.REEQUIP_DELAY) or 0.5
                task.wait(delaySec)
                if not config.SpeedBoost then return end
                local char = player.Character
                local hum  = char and char:FindFirstChildOfClass("Humanoid")
                if hum and (char and not char:FindFirstChild("Grapple Hook")) then
                    local bp = player:FindFirstChild("Backpack")
                    if bp and tool.Parent == bp then
                        pcall(function() hum:EquipTool(tool) end)
                    end
                end
            end)
        end
    end

    local function SB_rescanTools()
        SB_clearToolConns()
        local bp   = player:FindFirstChild("Backpack")
        local char = player.Character
        if bp then
            for _,t in ipairs(bp:GetChildren()) do SB_hookGrappleTool(t) end
            SB_bpAddedConn = bp.ChildAdded:Connect(function(child) SB_hookGrappleTool(child) end)
        end
        if char then
            for _,t in ipairs(char:GetChildren()) do SB_hookGrappleTool(t) end
        end
    end

    --========================================================
    -- SPAM RUNNER
    --========================================================
    local SB_GrappleSpamRunner = (function()
        local self = { conn = nil, acc = 0 }
        local FIXED_DT = 1/120
        function self:start()
            if self.conn then return end
            self.acc = 0
            self.conn = RunService.Heartbeat:Connect(LPH_NO_VIRTUALIZE(function(dt)
                self.acc += dt
                while self.acc >= FIXED_DT do
                    self.acc -= FIXED_DT
                    if config.SpeedBoost then
                        pcall(SB_FireGrappleNear)
                    end
                end
            end))
        end
        function self:stop()
            if self.conn then self.conn:Disconnect(); self.conn = nil end
            self.acc = 0
        end
        return self
    end)()

    --========================================================
    -- KHỞI TẠO CONTROLLERS
    --========================================================
    local SB_PARAMS = {
        EXTRA_SPEED         = config.SpeedBoost_Speed,
        MAX_SPEED           = 180,
        INTERVAL            = 1/120,
        RESP_GROUND         = 14,
        RESP_AIR            = 10,
        AIR_CONTROL         = true,
        AIR_STICK_TIME      = 0.25,
        AIR_NO_INPUT_GRACE  = 0.12,
        STICK_ONLY_IF_INPUT = true,
        PRESERVE_MOMENTUM   = true,
    }
    local SB_boost = SB_makeBoostController(SB_PARAMS)
    local SB_charAddedConn, SB_charRemovingConn = nil, nil

    local function SB_bindHumanoid(hum)
        local hrp = hum.Parent and hum.Parent:FindFirstChild("HumanoidRootPart")
        if not hrp then hrp = hum.Parent and hum.Parent:WaitForChild("HumanoidRootPart", 5) end
        if not hrp then return end
        SB_boost:start(hum, hrp)
    end

    local function SB_startAllIfEnabled()
        if not config.SpeedBoost then return end
        local char = player.Character
        local hum = char and char:FindFirstChildOfClass("Humanoid") or nil
        if not hum and char then hum = char:WaitForChild("Humanoid", 5) end
        if hum then SB_bindHumanoid(hum) end
        SB_rescanTools()
        SB_GrappleSpamRunner:start()

        if SB_charRemovingConn then SB_charRemovingConn:Disconnect(); SB_charRemovingConn = nil end
        if SB_charAddedConn then SB_charAddedConn:Disconnect(); SB_charAddedConn = nil end

        SB_charRemovingConn = player.CharacterRemoving:Connect(function()
            SB_boost:stop()
            SB_clearToolConns()
        end)
        SB_charAddedConn = player.CharacterAdded:Connect(function(c)
            local h = c:WaitForChild("Humanoid", 5)
            if h then SB_bindHumanoid(h) end
            if config.SpeedBoost then
                SB_rescanTools()
                SB_GrappleSpamRunner:start()
            end
        end)
    end

    local function SB_stopAll()
        SB_boost:stop()
        SB_GrappleSpamRunner:stop()
        SB_clearToolConns()
        if SB_charRemovingConn then SB_charRemovingConn:Disconnect(); SB_charRemovingConn = nil end
        if SB_charAddedConn then SB_charAddedConn:Disconnect(); SB_charAddedConn = nil end
    end

    --========================================================
    -- UI GỌN (CoreGui) + SAVE JSON tức thì
    --========================================================
    local function SB_createUI()
        local parentGui = (gethui and gethui()) or game:GetService("CoreGui")

        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = "SpeedBoostUI"
        screenGui.ResetOnSpawn = false
        screenGui.IgnoreGuiInset = true
        screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        screenGui.Parent = parentGui
        -- ÁP DỤNG giá trị từ file
        screenGui.Enabled = (config.SpeedBoostUIEnabled == true)

        -- LẮNG NGHE Enabled để save ngay khi bị đổi ở nơi khác
        screenGui:GetPropertyChangedSignal("Enabled"):Connect(function()
            SB_forceSaveUIEnabled(screenGui.Enabled)
        end)

        local frame = Instance.new("Frame")
        frame.Name = "Main"
        frame.Size = UDim2.fromOffset(200, 100)
        frame.Position = UDim2.new(0, 40, 0, 120)
        frame.BackgroundColor3 = Color3.fromRGB(24, 24, 28)
        frame.Parent = screenGui
        Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 10)
        local stroke = Instance.new("UIStroke", frame); stroke.Thickness = 1.5; stroke.Color = Color3.fromRGB(70,70,80); stroke.Transparency = 0.2

        local header = Instance.new("Frame")
        header.Name = "Header"
        header.Size = UDim2.new(1, 0, 0, 36)
        header.BackgroundTransparency = 1
        header.Parent = frame

        local title = Instance.new("TextLabel")
        title.Name = "Title"
        title.Text = "Chilli Speed Boost"
        title.Font = Enum.Font.GothamBold
        title.TextSize = 18
        title.TextColor3 = Color3.fromRGB(230, 230, 240)
        title.BackgroundTransparency = 1
        title.Position = UDim2.fromOffset(12, 8)
        title.Size = UDim2.fromOffset(150, 20)
        title.TextXAlignment = Enum.TextXAlignment.Left
        title.Parent = header

        local collapseBtn = Instance.new("TextButton")
        collapseBtn.Name = "Collapse"
        collapseBtn.Text = "X"
        collapseBtn.Font = Enum.Font.GothamBold
        collapseBtn.TextSize = 16
        collapseBtn.TextColor3 = Color3.fromRGB(240,240,240)
        collapseBtn.Size = UDim2.fromOffset(28, 28)
        collapseBtn.Position = UDim2.new(1, -34, 0, 4)
        collapseBtn.BackgroundColor3 = Color3.fromRGB(42, 44, 52)
        collapseBtn.AutoButtonColor = true
        collapseBtn.Parent = header
        Instance.new("UICorner", collapseBtn).CornerRadius = UDim.new(1, 0)

        local toggleBtn = Instance.new("TextButton")
        toggleBtn.Name = "Toggle"
        toggleBtn.Size = UDim2.fromOffset(160, 48)
        toggleBtn.Position = UDim2.fromOffset(20, 44)
        toggleBtn.BackgroundColor3 = Color3.fromRGB(52, 56, 68)
        toggleBtn.Text = ""
        toggleBtn.Parent = frame
        Instance.new("UICorner", toggleBtn).CornerRadius = UDim.new(0, 10)
        local tStroke = Instance.new("UIStroke", toggleBtn); tStroke.Thickness = 1.2; tStroke.Color = Color3.fromRGB(80,85,100)

        local onOff = Instance.new("TextLabel")
        onOff.BackgroundTransparency = 1
        onOff.Position = UDim2.fromOffset(12, 8)
        onOff.Size = UDim2.fromOffset(80, 20)
        onOff.Font = Enum.Font.GothamSemibold
        onOff.TextSize = 18
        onOff.Text = "OFF"
        onOff.TextXAlignment = Enum.TextXAlignment.Left
        onOff.TextColor3 = Color3.fromRGB(235,235,240)
        onOff.Parent = toggleBtn

        local valueBox = Instance.new("TextBox")
        valueBox.Name = "ValueBox"
        valueBox.Size = UDim2.fromOffset(70, 30)
        valueBox.Position = UDim2.new(1, -80, 0, 9)
        valueBox.TextEditable = true
        valueBox.ClearTextOnFocus = false
        valueBox.Text = tostring(config.SpeedBoost_Speed)
        valueBox.PlaceholderText = "0–180"
        valueBox.Font = Enum.Font.GothamSemibold
        valueBox.TextSize = 16
        valueBox.TextColor3 = Color3.fromRGB(25,25,28)
        valueBox.BackgroundColor3 = Color3.fromRGB(80, 180, 120)
        valueBox.Parent = toggleBtn
        Instance.new("UICorner", valueBox).CornerRadius = UDim.new(0, 8)
        local vbStroke = Instance.new("UIStroke", valueBox); vbStroke.Thickness = 1; vbStroke.Color = Color3.fromRGB(30,120,80)

        local topButton = Instance.new("TextButton")
        topButton.Name = "SB_TopButton"
        topButton.Text = "◯"
        topButton.Font = Enum.Font.GothamBold
        topButton.TextSize = 16
        topButton.TextColor3 = Color3.fromRGB(245,245,250)
        topButton.Size = UDim2.fromOffset(28, 28)
        topButton.Position = UDim2.new(0, 12, 0, 10)
        topButton.BackgroundColor3 = Color3.fromRGB(42, 44, 52)
        topButton.Visible = false
        topButton.Parent = screenGui
        Instance.new("UICorner", topButton).CornerRadius = UDim.new(1, 0)
        local topStroke = Instance.new("UIStroke", topButton); topStroke.Thickness = 1; topStroke.Color = Color3.fromRGB(80,85,100)

        -- helper bật/tắt ScreenGui & LƯU (ghi trực tiếp file)
        local function SB_setScreenVisible(vis)
            screenGui.Enabled = (vis == true)
            SB_forceSaveUIEnabled(screenGui.Enabled) -- <<<<<< GHI JSON NGAY Ở ĐÂY
        end

        -- drag
        do
            local dragging, dragStart, startPos = false, Vector2.zero, nil
            local function update(input)
                local delta = input.Position - dragStart
                local sp = startPos
                frame.Position = UDim2.fromOffset(sp.X.Offset + delta.X, sp.Y.Offset + delta.Y)
            end
            header.InputBegan:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                    dragging = true
                    dragStart = input.Position
                    startPos = frame.Position
                    input.Changed:Connect(function()
                        if input.UserInputState == Enum.UserInputState.End then dragging = false end
                    end)
                end
            end)
            header.InputChanged:Connect(function(input)
                if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
                    update(input)
                end
            end)
        end

        local function SB_setToggleVisual(on)
            onOff.Text = on and "ON" or "OFF"
            local toColor = on and Color3.fromRGB(80, 180, 120) or Color3.fromRGB(52, 56, 68)
            TweenService:Create(toggleBtn, TweenInfo.new(0.15), {BackgroundColor3 = toColor}):Play()
        end

        local function SB_applyValueFromBox(applyNow)
            local n = tonumber(valueBox.Text)
            if not n then valueBox.Text = tostring(config.SpeedBoost_Speed) return end
            n = math.clamp(math.floor(n + 0.5), 0, 180)
            valueBox.Text = tostring(n)
            config.SpeedBoost_Speed = n
            SB_PARAMS.EXTRA_SPEED = n
            SB_writeDisk({ SpeedBoost_Speed = n }) -- lưu chắc cú
            if applyNow and config.SpeedBoost then
                SB_boost:stop()
                SB_startAllIfEnabled()
            end
        end

        SB_setToggleVisual(config.SpeedBoost == true)

        toggleBtn.MouseButton1Click:Connect(function()
            -- click vùng rỗng của toggle, không đè TextBox
            local absPos, absSize = valueBox.AbsolutePosition, valueBox.AbsoluteSize
            local mouse = UserInputService:GetMouseLocation()
            if mouse.X >= absPos.X and mouse.X <= absPos.X + absSize.X and mouse.Y >= absPos.Y and mouse.Y <= absPos.Y + absSize.Y then
                return
            end
            local on = not config.SpeedBoost
            config.SpeedBoost = on
            SB_writeDisk({ SpeedBoost = on }) -- lưu trạng thái bật/tắt boost
            SB_setToggleVisual(on)
            if on then
                SB_setScreenVisible(true) -- bật UI + ghi JSON true
                task.spawn(function()
                    if not SB_findGrappleInInventory() then
                        print("[SpeedBoost] Grapple Hook không thấy. Thử mua tự động...")
                        local got = SB_ensureGrappleAvailable({attempts = 2, waitBetween = 0.5})
                        if got then print("[SpeedBoost] Đã có Grapple Hook.") else print("[SpeedBoost] Không mua được Grapple.") end
                    end
                    SB_startAllIfEnabled()
                end)
            else
                SB_stopAll()
            end
        end)

        valueBox.FocusLost:Connect(function() SB_applyValueFromBox(true) end)

        -- Thu gọn / mở rộng (không ảnh hưởng Enabled)
        local function SB_collapse()
            frame.Visible = false
            topButton.Visible = true
            config.SpeedBoostUICollapsed = true
            SB_writeDisk({ SpeedBoostUICollapsed = true })
        end
        local function SB_expand()
            frame.Visible = true
            topButton.Visible = false
            config.SpeedBoostUICollapsed = false
            SB_writeDisk({ SpeedBoostUICollapsed = false })
        end

        if config.SpeedBoostUICollapsed then
            frame.Visible = false
            topButton.Visible = true
        else
            frame.Visible = true
            topButton.Visible = false
        end

        collapseBtn.MouseButton1Click:Connect(function() SB_collapse() end)
        topButton.MouseButton1Click:Connect(function() SB_expand() end)

        return screenGui, SB_setScreenVisible
    end

    --========================================================
    -- KHỞI TẠO UI & START THEO CONFIG
    --========================================================
    local SB_ui, SB_setScreenVisible = SB_createUI()

    local function SB_setToggleVisualExternal(on)
        pcall(function()
            local main = SB_ui:FindFirstChild("Main"); if not main then return end
            local toggleBtn = main:FindFirstChild("Toggle"); if not toggleBtn then return end
            local onOff = toggleBtn:FindFirstChildOfClass("TextLabel")
            if onOff then onOff.Text = on and "ON" or "OFF" end
            local toColor = on and Color3.fromRGB(80, 180, 120) or Color3.fromRGB(52, 56, 68)
            TweenService:Create(toggleBtn, TweenInfo.new(0.15), {BackgroundColor3 = toColor}):Play()
        end)
    end
    SB_setToggleVisualExternal(config.SpeedBoost == true)

    --====== MACLIB TOGGLE CHO HIỂN THỊ UI (GHI JSON CHẮC CÚ) ======--
    local PlayerSec = PlayerDTKTab:Section({ Title = "Movement", Opened = true })
    PlayerSec:Toggle({
        Title    = "Speed boost UI (3 rebirth required, Q keybind on PC)",
        Default  = (config.SpeedBoostUIEnabled == true),
        Callback = function(show)
            local want = (show == true)
            SB_setScreenVisible(want)            -- cập nhật UI.Enabled + GHI JSON
            -- dây an toàn lần 2:
            if config.SpeedBoostUIEnabled ~= want then
                SB_forceSaveUIEnabled(want)
            end
        end
    })

    -- Hotkey Q: khi bật SpeedBoost thì ép bật UI + ghi JSON
    UserInputService.InputBegan:Connect(function(input, gpe)
        if gpe then return end
        if UserInputService:GetFocusedTextBox() then return end
        local keyEnum = Enum.KeyCode[ tostring(config.SpeedBoost_Key or "Q") ] or Enum.KeyCode.Q
        if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == keyEnum then
            local newState = not config.SpeedBoost
            config.SpeedBoost = newState
            SB_writeDisk({ SpeedBoost = newState })
            if newState then
                SB_setScreenVisible(true)    -- bật UI + GHI JSON true
                task.spawn(function()
                    if not SB_findGrappleInInventory() then
                        print("[SpeedBoost] (hotkey) Mua Grapple...")
                        local got = SB_ensureGrappleAvailable({attempts=2, waitBetween=0.5})
                        if got then print("[SpeedBoost] (hotkey) OK") end
                    end
                    SB_startAllIfEnabled()
                end)
            else
                SB_stopAll()
            end
            SB_setToggleVisualExternal(newState)
        end
    end)

    -- AUTO-APPLY THEO JSON LÚC KHỞI ĐỘNG
    if config.SpeedBoost then
        SB_setScreenVisible(true) -- sẽ GHI JSON true nếu đang false
        task.spawn(function()
            if not SB_findGrappleInInventory() then
                print("[SpeedBoost] Khởi tạo: mua Grapple...")
                local ok = SB_ensureGrappleAvailable({attempts=2, waitBetween=0.5})
                if ok then print("[SpeedBoost] Đã có Grapple.") else print("[SpeedBoost] Không mua được Grapple.") end
            end
            SB_startAllIfEnabled()
        end)
    end
end

